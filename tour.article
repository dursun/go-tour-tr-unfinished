Go Turu

Go Yazarlar� Sunar
http://golang.org

# Bu dosya i�erisinde #appengine komutuyla ba�layan
# sat�rlar var. Bu sat�rlar tur i�eri�i, bir App Engine
# uygulamas� olarak y�klendi�inde i�e yarar.
# Ayr�ca, #appengine sat�r�n�n arkas�na gelen bo� olmayan
# sat�rlar saklanacakt�r. Bu App Engine'�n �zel-i�eri�inin
# de�i�tirilebilmesiyle alakal� bir durum.
# �rne�in, bu paragraf
# 	We are running
# 	#appengine: on App Engine.
# 	locally.
# 	Yay!
# App Engine'da "We are running on App Engine. Yay!" �eklinde okunurken,
# di�er durumlarda "We are running locally. Yay!" �eklinde okunur.

* Merhaba, ??

 [[http://golang.org/][Go programlama dili ]] turuna ho� geldiniz.

Turumuz 3 b�l�mden olu�maktad�r ve her b�l�m�n sonunda bir dizi al��t�rmay� tamamlaman�z bekleniyor.

Turumuz etkile�imlidir. Program� uzak sunucu �zerinde derleyip, �al��t�rmak i�in "Çalıştır"   butonuna t�klay�n (ya da Shift-Enter tu�lay�n) kod derlenip, program
#appengine: uzak sunucuda
kendi bilgisayar�n�zda
�al��t�r�lacak.

Sonu� kodun a�a��s�nda g�sterilecek.

�rnek programlar sizi Go'nun farkl� y�nleriyle tan��t�rarak, gelecekteki tecr�beleriniz i�in ilk ad�mlar� olu�turacak.

Program� d�zenleyip yeniden �al��t�r�n.

�lerlemeye haz�r oldu�unuzda "İleri" butonuna t�klay�n ya da PageDown tu�lay�n.
.play prog/hello.go

* Go lokal

Turu di�er dillerle de deneyebilirsiniz:

- [[http://go-tour-br.appspot.com/][Brazilian Portuguese � Portugu�s do Brasil]]
- [[http://go-tour-ca.appspot.com/][Catalan � Catal�]]
- [[http://go-tour-he.appspot.com/][Hebrew � ????????]]
- [[http://go-tour-jp.appspot.com/][Japanese � ???]]
- [[http://go-tour-ro.appspot.com/][Romanian - Rom�na]]
- [[http://go-tour-zh.appspot.com/][Chinese � ???]]

Devam etmek i�in "İleri" butonuna t�klay�n ya da Page Down tu�lay�n.

* Paketler

Her Go program� paketlerden olu�ur.

Programlar `main` paketinde �al��maya ba�lar.

Bu �rnek program `"fmt"` ve `"math"` paketlerini import yolu ile kullan�yor.

Geleneksel olarak, paket isimleri import yolunun son elementi ile isimlendirilir.

.play prog/packages.go

* ��e Aktar�mlar

Bu kod gruplar� import ifadesini parantezlenmi� ifadenin i�ine aktar�rlar. Ayr�ca �oklu import ifadeleri de kullanabilirsiniz:

	import "fmt"
	import "math"
ancak kar���kl��� �nlemek i�in genellikle di�er form kullan�l�r.

.play prog/imports.go

* ��e Aktar�lan �simler

Bir paketi i�e aktard�ktan sonra, sahip oldu�u isimleri de aktarabilirsiniz. 

Go'da, d��a aktar�lm�� bir isim b�y�k harf ile ba�lar.

T�pk� `FOO` gibi `Foo` da d��a aktar�lm�� bir isimdir. `foo` d��a aktar�lm�� bir isim de�ildir.

Kodu �al��t�rmay� denedikten sonra `math.pi` ifadesini <code>math.Pi</code> �eklinde de�i�tirip yeniden �al��t�r�n.

.play prog/exported-names.go

* Fonksiyonlar

Bir fonksiyon 0 veya daha fazla arg�man alabilir.

Bu �rnekte, `add` fonksiyonu `int` tipinde 2 parametre al�yor.

Tip tan�mlamas�n�n de�i�ken ad�ndan _sonra_ yap�ld���na dikkat edin!

(Tiplerin neden buna ihtiya� duyduklar� hakk�nda daha fazla bilgi i�in, [[[http://golang.org/doc/articles/gos_declaration_syntax.html][buraya]] bak�n makale Go'nun "syntax ifadesi"ndendir.)

.play prog/functions.go

* Fonksiyonlar

Ard���k gelen 2 ya da daha fazla parametre ayn� tipi payla��yorsa, tip ad�n� en sona yazarak tan�mlama yapabiliriz.

Bu �rnekte,

x int, y int

kod par�as� a�a��daki �ekilde k�salt�lm��;

x, y int

.play prog/functions-continued.go

* �oklu sonu�lar

Bir fonksiyon herhangi bir say�da sonu� d�nd�rebilir.

�rnekteki fonksiyon dizgi tipinde 2 sonu� d�nd�r�yor.

.play prog/multiple-results.go

* �simlendirilmi� sonu�lar

Fonksiyonlar parametreler al�rlar. Go'da fonksiyonlar birden fazla sonu� ("result") parametresi alabilir. Sonu�lar da de�i�ken gibi isimlendirilebilir
ve o �ekilde davrabilir.

E�er sonu� parametreleri isimlendirilmi�se, arg�mans�z bir `return` ifadesi sonu�lar�n ge�erli de�erini d�nd�recektir.
.play prog/named-results.go

* De�i�kenler

`var` ifadesi ile de�i�kenleri tan�mlar�z;
t�pk� fonksiyon arg�manlar� gibi, tip tan�mlamas� sonda yap�l�r.

.play prog/variables.go

* De�i�kenler-�lklendirme

Bir `var` ifadesi her de�i�ken i�in bir ilklendirme de�eri i�erebilir.

E�er bir ilklendirme mevcut ise, tip tan�mlamas� atlanabilir;
de�i�ken ilklendirme de�erinin tipini alacakt�r.


Bir var ifadesi tan�mlay�c� i�erebilir, her de�i�kene bir tane.

E�er bir tan�mlay�c� mevcut ise, tip atlanabilir; de�i�ken tan�mlay�c�s�n�n tipini alacakt�r.

.play prog/variables-with-initializers.go

* K�sa atama ifadeleri

Bir fonksiyon i�erisinde, `var` ifadesinin yerine `:=` yap�s� kullan�labilir .

(Fonksiyonun d���nda, her yap� bir anahtar kelime ile ba�lar ve `:=` yap�s�n� kullanmak m�mk�n de�ildir.)

.play prog/short-variable-declarations.go

* Basit tipler

Go'nun basit tipleri �unlard�r

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // di�er ad�yla uint8

	rune // di�er ad�yla int32
	     // represents a Unicode code point

	float32 float64

	complex64 complex128

.play prog/basic-types.go

* Sabitler

Sabitler de de�i�kenler gibidir ama const anahtar kelimesi ile kullan�l�rlar.

Sabitler, karakter, dizgi, boolean, ya da say�sal de�erler alabilir.

.play prog/constants.go

* Say�sal Sabitler

Say�sal sabitler y�ksek hassasiyetli _de�erlerdir_.

Tipi olmayan bir sabit kayna��n�n ihtiya� duydu�u tipi al�r.

`needInt(Big)` kodunu da eklemeyi deneyin.

.play prog/numeric-constants.go

* For

Go dilinde sadece `for` d�ng�s� mevcuttur.

`for` d�ng�s� C ya da Java'dakiyle benzer yap�dad�r, ancak `(`)` k�sm� (parantezler) kullan�lmaz (opsiyonel de�il) 

bunun yan�nda `{`}` k�sm�n�n kullan�lmas� �artt�r.

.play prog/for.go

* For devam�

T�pk� C ve Java'daki gibi, ilk ve son ifadeleri bo� b�rakabilirsiniz.

.play prog/for-continued.go

* For, Go'nun "while"�

Bu durumda, noktal� virg�lleri kullanmayabilirsiniz: C'deki `while`'�n kar��l��� Go'da `for`'dur.

.play prog/for-is-gos-while.go

* Sonsuzluk

E�er d�ng� ko�ulunu belirtmezseniz, sonsuz d�ng� olu�acakt�r.

.play prog/forever.go

* If

`if` ko�ulu C ve Java'dakiyle benzer yap�dad�r ancak `(`)` (parantezlerin) yerini` {`}` (s�sl� parantezler) al�r.

(Tan�d�k m� geldi?)

.play prog/if.go

* K�sa atama ile if

`for`'daki gibi, `if` ifadesi de ko�uldan �nce �al��t�r�labilmesi i�in k�sa atama ile ba�layabilir.

De�i�kenlerin ge�erlili�i `if` ifadesinin kapsam� i�indedir.

(Sondaki return ifadesinde `v` kullanmay� deneyin.)

.play prog/if-with-a-short-statement.go

* If ve else

`if`'in i�erisinde k�sa atama ile atanan de�i�kenlerin kullan�m� `else` bloklar�nda da m�mk�nd�r.

.play prog/if-and-else.go

* Uygulama: D�ng�ler ve Fonksiyonlar

Newton� un y�ntemini kullanarak karek�k alma fonksiyonu ger�eklemek, fonksiyon ve d�ng� kullanarak al��t�rma yapman�n kolay bir yoludur.

Newton'un metodu kendisine bir _z_ ba�lang�� noktas� se�er ve

.image static/newton.png

form�l�n� tekrarlayarak `Sqrt(x)` de�erine yakla��r.

Ba�lang�� olarak, bu hesaplamay� 10 defa tekrar edin ve (1, 2, 3, ...) gibi �e�itli de�erlerde cevaba ne kadar yakla�t���n�z� g�r�n.

Daha sonra, d�ng� ko�ulunu, sonu� de�eri de�i�meyi b�rakt���nda (ya da �ok k���k bir delta ile de�i�ti�inde) D�ng�n�n duraca�� �ekilde bi�imlendirin.

Daha fazla ya da daha az yineleme i�in buraya g�z at�n.

[[http://golang.org/pkg/math/#Sqrt][`Math.sqrt`'ye]] ne kadar yak�ns�n�z?

�pucu: bir kayan nokta de�erini (floating point value)ifade etmek ve tan�mlamak i�in kayan nokta s�z dizimi verin ya da bir d�n��t�rme uygulay�n:

	z := float64(1)
	z := 1.0

.play prog/exercise-loops-and-functions.go

* Yap�lar

Bir struct (yap�) alanlar�n toplamas�d�r.

(Ve bir `type` ifadesi bekleneni ger�ekle�tirir.)

.play prog/structs.go

* Yap� Alanlar�

Yap� alanlar� nokta kullan�larak �a�r�l�r

.play prog/struct-fields.go

* ��aret�iler

Go'nun i�aret�ileri var ama i�aret�i aritmeti�i yok.

Yap� alanlar�na bir yap� i�aret�isi ile de eri�ilebilir. ��aret�i ile sa�lanan bu dolayl� yol �effaft�r.

.play prog/pointers.go

* Yap�sal Sabitler

Yap�sal sabitler, hen�z tahsis edilmi� yap� de�erini, alan�na g�re listeleyerek belirtir.

`Name`: s�zdizimini kullanarak yaln�zca alt alanlar� listeleyebilirsiniz (S�ras�yla isimlendirilmi� alanlar konu d���ndad�r.)

�zel `&` g�sterimi yap�sal bir sabite i�aret�i tahsis eder.

.play prog/struct-literals.go

* Yeni fonksiyon

`new(T)` ifadesi, s�f�rlanm�� bir `T` de�eri tahsis eder ve ona bir i�aret�i d�nd�r�r.

	var t *T = new(T)

or

	t := new(T)

.play prog/the-new-function.go

# TODO(campoy): Dizilerin b�l�m�

* Dilimler

Bir dilim de�erlerden olu�an bir diziyi i�aret etmesinin yan�nda uzunlu�unu da belirtir.

`[]T`, `T` tipinden elemanlar� olan bir dilimdir.

.play prog/slices.go

* Dilim dilim dilimlemek

Bir dilim, ayn� diziyi i�aret eden yeni bir dilim de�eri olu�turmak i�in yeniden dilimlenebilir.

	s[lo:hi]

ifadesi `"lo"`dan `"hi-1"`i de kapsayan elemanlar� de�erlendirir. Buna g�re

	s[lo:lo]

dilimi bo�tur,

	s[lo:lo+1]

dilimi ise bir elemana sahiptir.

.play prog/slicing-slices.go

* Dilim yaratmak

Dilimler `make` fonksiyonu ile yarat�l�r.�al��ma mant���; bellekte s�f�rlanm�� bir dizi tahsis ederek ve bu diziyi i�aret eden bir dilim d�nd�rmektir:

	a := make([]int, 5)  // len(a)=5

Kapasiteyi belirtmek i�in, `make`'e bir ���nc� arg�man atayal�m:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play prog/making-slices.go

* Nil dilimler

Bo� bir dilimin de�eri `nil`'dir.

B�yle dilimlerin uzunluk ve kapasite de�erleri 0'd�r.

(Dilimler hakk�nda daha fazla bilgi i�in: [[http://golang.org/doc/articles/slices_usage_and_internals.html] makalesini okuyun)

.play prog/nil-slices.go

# TODO(campoy): Dilimler b�l�m�ne ekleme 

* [Erim]("Range")

`for` d�ng�s�n�n `range` formu ile bir dilim veya e�lem �zerinde dola��l�r.

.play prog/range.go

* Range devam�

�ndisi ya da de�eri `_` atamas� ile atlayabilirsiniz.

E�er yaln�zca indisi istiyorsan�z, �, value� ifadesini tamamen ��karabilirsiniz.

.play prog/range-continued.go

* Uygulama: Dilimler

`"Pic"`i ger�ekleyin. Fonksiyonunuz `dx`'in (8 bitlik i�aretsiz tam say�lar) dilimi olan her bir eleman i�in, `dy` uzunlu�unda bir dilim d�nd�rmelidir.

Program� �al��t�rd���n�zda, sizin foto�raf�n�z� g�sterecek, tamsay�lar� gri�l�ekli (*/uygun �eviri de�il*/, mavi�l�ekli) de�erler olarak ��karacakt�r.

Resim se�imi size ait. Kullanaca��n�z fonksiyonlar `x^y`, `(x+y)/2` ve `x*y` ifadelerini i�ermektedir.

(`[][]uint8` i�erisindeki her "`[]uint8`"i ay�rmak i�in d�ng� kullanman�z gerekmektedir.)

(Tipler aras�nda d�n���m yapmak i�in uint8(intValue) kullan�n.)

.play prog/exercise-slices.go

* E�lemler

Bir e�lem ("map") anahtarlar� de�erlere e�ler.

E�lemler mutlaka `make` ile yarat�lmal�d�r (`new` ile de�il) `nil` tipindeki bir e�lem bo�tur ve atanabilir de�ildir.


.play prog/maps.go

* Map de�i�mezleri

E�lem de�i�mezleri de yap� de�i�mezlerine benzer yap�dad�r ancak anahtarlarla birlikte kullan�l�r.

.play prog/map-literals.go

* Map de�i�mezleri devam�

E�er �st-seviye tip yaln�zca tip ad� ise, onu de�i�mezin elemanlar� aras�nda g�rmezden gelebilirsiniz. /*kendime not daha uygun bir �eviri ara */

.play prog/map-literals-continued.go

* E�lemleri De�i�tirme
E�lemimize ("map") bir eleman ekleyelim ya da varolan bir eleman� g�ncelleyelim  `m`:

	m[key] = elem

Bir eleman� �ekelim:

	elem = m[key]

Bir eleman� silelim:

	delete(m, key)

�ift-de�er atamas�ndaki anahtar� test edelim:

	elem, ok = m[key]

E�er `key`, `m` i�indeyse, `ok`, `true` de�erini alacakt�r. E�er de�ilse, `ok`, `false` de�erini alacak ve `elem`, 

e�lemin eleman tipi i�in s�f�r de�erini alacakt�r.

Benzer �ekilde, bir e�lemden okurken e�er anahtar mevcut de�ilse Sonu�, e�lemin eleman tipi i�in s�f�r de�erini al�r.

.play prog/mutating-maps.go

# TODO(campoy): Range on maps section

* Uygulama: E�lemler

`WordCount` fonksiyonunu ger�ekleyin. Fonksiyonunuz `s` dizgisinin i�erisindeki her bir �kelime� i�in bir e�lem d�nd�rmelidir. `wc.Test` fonksiyonu, fonksiyonunuzu test edecek ve ba�ar�y� ya da ba�ar�s�zl��� ��kt� olarak verecektir.

"[[http://golang.org/pkg/strings/#Fields][strings.Fields]]"a bakman�zda fayda var.

.play prog/exercise-maps.go

* Fonksiyon de�erleri

Fonksiyonlar da birer de�erdir.

.play prog/function-values.go

* Fonksiyon - kaplamlar

Fonksiyonlar kaplamlarla ("closure") doludur.

`adder` fonksiyonu bir kaplam d�nd�r�r. Her kaplam kendi `sum` de�i�kenini saklar.

.play prog/function-closures.go

* Uygulama: Fibonacci closure

Hadi fonksiyonlarla biraz e�lenelim.

`Fibonacci` uygulamas� ard���k Fibonacci say�lar�n� d�nd�ren bir fonksiyonu, kaplam� d�nd�r�r.

.play prog/exercise-fibonacci-closure.go

* Anahtarlama

Muhtemelen `"switch"` yap�s�n�n ne �ekilde �al��t��� hakk�nda biraz bilginiz vard�r.

`"fallthrough durumu"` olu�mamas� halinde, uygun case g�vdesi �al��acakt�r . /* �evirimin uygunlu�u hakk�nda ��phelerim var */

.play prog/switch.go

* Anahtarlama de�erlendirme s�ras�

"Switch", "case"lerini ba�tan a�a�� de�erlendirir, "case"lerden biri do�rulan�rsa de�erlendirme i�lemi durur.

(�rne�in,

	switch i {
	case 0:
	case f():
	}

e�er`i==0` ise `f`'yi �a��rmaz.)

#appengine: *Note:* Time in the Go playground always appears to start at
#appengine: 2009-11-10 23:00:00 UTC, a value whose significance is left as an
#appengine: exercise for the reader.

.play prog/switch-evaluation-order.go

* Ko�ulsuz Anahtarlama

Ko�ul belirtilmemi� bir "switch" ifadesi `"switch`true"` ifadesi ile ayn� i�i g�r�r.

Ve uzun "if-then-else" zincirleri yerine kullan�labilecek, g�zel bir y�ntemdir.

.play prog/switch-with-no-condition.go

* Geli�mi� Uygulama: Karma��k k�p k�kler

Go'nun kompleks say�lar i�in, i�inde bulundurdu�u `complex64` ve `complex128` tiplerini inceleyelim. K�p k�kler i�in, Newton'un y�ntemi:

.image static/newton3.png

form�l�n� tekrarlayarak sonuca gider.

Algoritman�n �al��t���ndan emin olmak i�in, 2'nin k�p k�k�n� bulun. `math/cmplx` paketinin i�inde bir [[http://golang.org/pkg/math/cmplx/#Pow][Pow]] fonksiyonu bulunmaktad�r.

.play prog/advanced-exercise-complex-cube-roots.go

* Metodlar ve Aray�zler

* Metodlar

Go dilinde s�n�f yap�s� bulunmamas�na kar��n "struct" tiplerinde metod tan�mlayabilirsiniz.

_Metod_al�c�s�_ , `func` anahtar s�zc��� ve metod ismi aras�nda kendi arg�man listesinde bulunur.

.play prog/methods.go

* Metodlar devam�

Hatta sadece "struct"larda de�il, metodunuzu paketinizde tan�mlad���n�z _herhangi_ bir tipte de tan�mlayabilirsiniz.

Ba�ka bir paketten alaca��n�z bir tipte ya da temel bir tipte metod tan�mlayamazs�n�z.

.play prog/methods-continued.go

* ��aret�i al�c�lar�yla metodlar

Metodlar isimlendirilmi� tiplerle ya da isimlendirilmi� bir tipi g�steren i�aret�ilerle ili�kilendirilebilir.

Hen�z, biri `*Vertex` i�aret�i tipinde ve di�eri ise `MyFloat` de�er tipinde olmak �zere iki `Abs` metodu g�rd�k.

��aret�i al�c�s� kullanmam�z�n iki nedeni var. Birincisi, her metod �a�r�s�nda, de�er kopyalamas�ndan ka��nmak (e�er tipi "large struct" ise daha verimli). �kincisi, metodun i�aret�iler sayesinde de�eri g�ncelleyebimesidir.

`*Vertex` yerine `Vertex`'i al�c� olarak kullanmak i�in `Abs` ve `Scale` metod ifadelerini de�i�tirmeyi deneyin.

`v` bir `Vertex` oldu�unda, `Scale` Metodunun bir i�levi yoktur. `Scale`, `v`'yi d�n��t�r�r. `v` bir de�er oldu�unda (i�aret�i-de�il), metod onu `Vertex`'in bir kopyas� olarak g�recek ve as�l de�eri d�n��t�rmeyecektir.

`Abs`  di�er bir �ekilde de �al���r. Yaln�zca `v`'yi okur. Burada as�l ifadeyi okumas�yla kopyalanm�� ifadeyi okumas� (i�aret�i vas�tas�yla) aras�nda bir fark yoktur.

.play prog/methods-with-pointer-receivers.go

* Aray�zler

Bir aray�z ("interface") tipi bir dizi metod taraf�ndan belirlenir.

Aray�z tipinin herhangi bir de�eri metodar� ger�ekleyen de�erlerden herhangi birini tutabilir.

.play prog/interfaces.go

* Aray�zler

Bir tip, aray�z�, ger�eklenen metodlar� kullanarak ger�ekler. /* �ok k�t� bir �eviri oldu �zerinde d���nmek gerek 

_Niyetin_a�ikar_bir_a��klamas�_yoktur._ /* bu �eviriyi uygun bulmamakla birlikte daha d�zg�n bir �eviri �nerisi sunam�yorum */

Soyutlanm�� aray�zler, uygulama paketlerini aray�zlerin tan�mland��� 

paketlerden ay�r�rlar: birbirlerine ba�l� da de�illerdir.

Ayn� zamanda �do�ru terimi bulamad�m- aray�zlerin tan�mlanmas� i�in te�vik eder, ��nk�

her uygulamay� tek tek bulup yeni bir aray�z ismiyle etiketlemek zorunlulu�unu ortadan kald�r�r.

[[http://golang.org/pkg/io/][Package io]], `Reader` ve `Writer`'� otomatik olarak tan�mlar.

.play prog/interfaces-are-satisfied-implicitly.go

* Hatalar

Kendini hata dizgisi olarak tarif edebilen her �ey bir "hata"d�r.

Bu fikir �nceden tasarlanm��, yerle�ik aray�z tipinde, `error`'da,

dizgi d�nd�ren, kendi tekil metoduyla (`Error`) saklan�r,:

`fmt` paketlerinin kendi ��kt� tipleri bir "`error`"

��kt�s� istendi�inde onu nas�l sunacaklar�n� otomatik olarak bilir.

.play prog/errors.go

* Uygulama: Hatalar

`Sqrt` fonksiyonunuzu �nceki egzersizlerden kopyalay�n ve onu bir `error` (hata) de�eri d�nd�recek �ekilde d�zenleyin.

`Sqrt` fonksiyonunuz negatif bir say� verildi�inde, t�pk� kompleks say�lar� desteklemedi�inde yapaca�� gibi. nil olamayan bir hata mesaj� d�nd�rmelidir, 

Yeni bir tip olu�turun

	type ErrNegativeSqrt float64

ve ona bir

	func (e ErrNegativeSqrt) Error() string

metodu ekleyere `error` haline getirin `ErrNegativeSqrt(-2).Error()`'un `"Negatif say�lar�n karek�k� al�namaz: -2"` d�nd�rmesi gibi.

*Not:* `Error` metodunun i�indeki `"fmt.Print(e)"`e yap�lan bir �a�r� program� sonsuz bir d�ng�n�n i�erisine sokacakt�r. �ncelikle e'yi de�i�tirerek bunu �nleyebilirsiniz: `fmt.Print(float64(e))`. Neden?

`Sqrt` fonksiyonunuzu negatif say� verildi�inde `ErrNegativeSqrt` d�nd�recek bi�imde de�i�tirin.

.play prog/exercise-errors.go

* Web sunucular�

[[http://golang.org/pkg/net/http/][http paketi]] HTTP isteklerini, http.Handler� � ger�ekleyen de�erleri kullanarak kar��lar:

	package http

	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

Bu �rnekte, Hello tipi "http.Handler"� ger�ekliyor.

Selamlamay� g�rmek i�in [[http://localhost:4000/][http://localhost:4000/]]'i ziyaret edin.

#appengine: *Note:* Bu �rnek web-tabanl� kullan�c� aray�z�nde �al��mayacakt�r.
#appengine: Web sunucusu yazmay� denemek i�in 
#appengine: [[http://golang.org/doc/install/][Go'yu y�kleyin]].

.play prog/web-servers.go

* Uygulama: HTTP ��leyicileri

ServeHTTP metodlar�n� tan�mlamak i�in a�a��daki tipleri kullan�n. Web sunucunuzdaki spesifik yollar� kontrol edebilmek i�in kaydedin.

	type String string

	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

�rne�in, i�leyici kay�tlar�n� kaydedebilir olmal�s�n�z:

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

.play prog/exercise-http-handlers.go

* G�r�nt�ler

[[http://golang.org/pkg/image/#Image][image paketi]], `Image` aray�z�n� tan�mlar:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

(Detaylar i�in [[http://golang.org/pkg/image/#Image][bu dok�mana]] g�z at�n.)

Ayr�ca, `color.Color` ve `color.Model` da birer aray�zd�r ancak `color.RGBA` ve `color.RGBAModel` �ntan�ml� uygulamalar� i�in bunu g�rmezden gelece�iz.

.play prog/images.go

* Uygulama: G�r�nt�ler

Daha �nceden yazd���n�z g�r�nt� vericiyi hat�rlad�n�z m�? Hadi bir tane daha yazal�m ama bu defa bir veri dilimi d�nd�rmek yerine `image.Image` d�nd�rs�n.

Kendi Image tipinizi tan�mlay�n, [[http://golang.org/pkg/image/#Image][gerekli metodlar�]] ger�ekleyin ve "`pic.ShowImage`"i �a��r�n.

`Bounds`, `image.Rect(0, `0, `w, `h)` gibi bir `image.Rectangle` d�nd�rmelidir.

`ColorModel`, `color.RGBAModel` d�nd�rmeli.

`At` bir renk d�nd�rmelidir; son g�r�nt� vericideki `v` de�eri bu defa `color.RGBA{v, `v, `255, `255}`'e tekab�l etmelidir.

.play prog/exercise-images.go

* Uygulama: Rot13 Okuyucu

Bilindik modellerden biri [[http://golang.org/pkg/io/#Reader][io.Reader]]'�n  `ba�ka bir io.Reader`' � sar�p, bir �ekilde ak��� d�zenlemesidir. /* %100 emin de�ilim wrap ve stream terimlerine tekrar g�z atmak laz�m*/

�rne�in, [[http://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]]
fonksiyonu bir `io.Reader` al�r ("gzipped" verinin bir par�as�)
ve onu bir `*gzip.Reader`'a �evirir ayr�ca
`io.Reader`'� da ger�ekler (s�k��t�r�lm�� verinin bir par�as�).

[[http://en.wikipedia.org/wiki/ROT13][ROT13]] kullanarak alfabedeki t�m harfleri �ifreleyen 
`io.Reader`'dan okuyup yine `io.Reader`'a yazan bir `rot13Reader`'�, 
veri ak���n� d�zenleyerek uygulay�n.
`rot13Reader` tipini kullanabilirsiniz. `Read` metodunu
kullanarak onu bir `io.Reader` haline getirin.

.play prog/exercise-rot-reader.go

* E�zamanl�l�k

* Go rutinleri

"_gorutini_" Go taraf�ndan y�netilen hafif bir i� par�ac���d�r.

	go f(x, y, z)

	yeni bir gorutini ba�lat�r

	f(x, y, z)

'`f`', '`x`', '`y`' ve '`z`'nin
de�erlendirilmesi ayn� gorutinde `f`'nin i�inde, `f`'nin
de�erlendirilmesi ise yeni bir gorutininde ger�ekle�ir.

Gorutinleri ayn� adres bo�lu�unda �al���r, bu y�zden payla��lm�� bellek eri�imi
mutlaka senkronize edilmelidir. `[[http://golang.org/pkg/sync/][sync]]` paketi yararl� "ilkellikler" sa�lar,
yine de Go'da ba�ka "ilkel paketler" oldu�undan buna �ok ihtiya� duymayacaks�n�z.
(Bir sonraki slayta ge�in.)

.play prog/goroutines.go

* Kanallar

Kanallar, kanal operat�r� vas�tas�yla de�er g�nderip alabildi�iniz veri ak��� sa�layan birer tiptir, `<-`.

	ch <- v    // v'yi ch kanal�na yolla.
	v := <-ch  // ch'den al ve
           // de�eri v'ye ata.

	(Veri ak��� ok y�n�nde ger�ekle�ir.)

	T�pk� e�lemler ve dilimler gibi kanallar da:

	ch := make(chan int)

kullan�lmadan �nce olu�turulmal�d�r.
Varsay�lan olarak, di�er taraf da haz�r oldu�unda blok g�nderme/alma i�lemleri yap�l�r.
Bu da gorutinlerini a��k kilitlenmelerden ya da ko�ullu de�i�kenlerin senkronize
edilememesinden korur.

.play prog/channels.go

* Tamponlu Kanallar

Kanallar _tamponlanabilir_.  Tamponlanm�� bir kanal� tan�mlamak i�in
ikinci arg�man� `make` edip, tampon uzunlu�unu temin edin:

	ch := make(chan int, 100)

Kodu, blo�u yaln�zca tampon dolu oldu�unda tamponlanm�� kanala g�nderir. /* daha d�zg�n bir �eviri �nerim yok ancak �zerinde �al��mam�z gerek */

Tampon bo� oldu�unda ise blo�u temin eder. /* daha d�zg�n bir �eviri �nerim yok ancak �zerinde �al��mam�z gerek */

�rne�i, tampon gere�inden fazla dolacak �ekilde d�zenleyip, ne oldu�unu g�zlemleyin.

.play prog/buffered-channels.go

* Range and Close

G�nderici bir kanal� daha fazla de�er al�nmamas� gerekti�inde 
`close` kodu ile kapatabilir. Al�c�lar, al�c� ifadeye ikinci bir parametre atamas� yaparak
kanal�n kapal� olup olmad���n� ��renebilir:

	v, ok := <-ch

E�er al�nacak ba�ka de�er kalmam�� ve kanal kapat�lm��sa `ok`, `false` de�erini alacakt�r.

`for i := range c` d�ng�s� de�erleri kanaldan kanal kapanana kadar d�zenli olarak al�r.

*Not:* Yaln�zca g�nderen kanal� kapatmal�d�r, al�c� asla kapatmamal�d�r.
Kapal� kanala bir �eyler g�ndermek pani�e yol a�abilir.

*Bir*ba�ka*not*: Kanallar dosya gibi de�ildir; genellikle kapatma ihtiyac�
duyulmaz. Kapatma i�lemi yaln�zca al�c�ya daha ba�ka de�er gelmeyece�ini bildirmek
maksad�yla yap�l�r, t�pk� bir "`range`" d�ng�s�n� sonland�rmak gibi.

.play prog/range-and-close.go

* Se�mek

"`select`" ifadesi gorutinin birden fazla ileti�im i�leminde beklemesine izin verir.

Bir `select` "case"lerinden biri �al��t�r�labilene kadar t�kal�d�r, uygun duruma geldi�inde
"case"i �al��t�r�r.  E�er birden fazla �al��t�r�labilir "case" varsa se�imi rastgele ger�ekle�tirir.

.play prog/select.go

* Varsay�lan Se�im

"`default` �case� i, "`select`" in i�erisindedir e�er haz�rda ba�ka case yoksa �al��t�r�l�r.

"<code>default</code> case"i bloklama yapmadan alma ya da g�nderme yapmak i�in deneyin:

	select {
	case i := <-c:
		// i'yi kulllan
	default:
		// c'den almak bloklamal�yd�
	}

.play prog/default-selection.go

* Uygulama: E�de�er Binary A�a�lar�

De�erleri ayn� s�rada depolanm�� birden fazla binary apac� olabilir.
�rne�in, burada iki binary a�ac� var 1, 1, 2, 3, 5, 8, 13.

.image static/tree.png

Bir �ok dilde, ayn� s�rada iki binary a�ac� olup olmad���n� kontrol eden fonksiyon bir fonksiyon ger�eklemek
bir hayli kar���kt�r. Daha basit bir ��z�m sunabilmek ad�na Go'nun e�zamanl�l���n� ve kanallar�n� kullanaca��z.

Bu �rnek <code>tree</code> paketini kullan�r, bu paket:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}

tiplerini tan�mlar.

* Uygulama: E�de�er Binary A�a�lar�

*1.* `Walk` fonksiyonunu �a��r�n.

*2.* `Walk` fonksiyonunu test edin.

"`tree.New(k)`" fonksiyonu `k`, `2k`, `3k`, ..., `10k` de�erlerini tutarak rastgele-yap�land�r�lm��
bir binary a�ac� in�a eder.

`ch` ad�nda bir kanal olu�turun ve walker'� d��ar� at�n:

	go Walk(tree.New(1), ch)

Daha sonra kanaldan 10 de�erini okuyun ve yaz�n. De�erler 1, 2, 3, ..., 10 olmal�.

*3.* `t1` ve `t2`'nin ayn� de�erleri saklamas�na kar��n `Same` fonksiyonunu `Walk` kullanarak uygulay�n.

*4.* `Same` fonksiyonunu test edin.

`Same(tree.New(1),`tree.New(1))` true d�nd�rmeli ve `Same(tree.New(1),`tree.New(2))` false d�nd�rmeli.

.play prog/exercise-equivalent-binary-trees.go

* Uygulama: Web Crawler

Bu uygulamada Go'nun e�zamanl�l�k �zelli�ini web crawler ile paralelle�tirmeyi ��reneceksiniz.

`Crawl` fonksiyonunu paraleldeki URL'leri �ekecek bi�imde d�zenleyin, ayn� URL'yi iki defa �ekmemesine dikkat edin.

.play prog/exercise-web-crawler.go

* Buradan nereye gidiyoruz...

#appengine: [[http://golang.org/doc/install/][Go y�kleyerek]] ya da
#appengine: [[http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go][Go App Engine SDK]]
#appengine: indirerek ba�layabilirsiniz.

#appengine: Bir defa Go'yu y�kledi�inizde,
The
[[http://golang.org/doc/][Go Dok�mantasyonu]] ba�lang�ca
#appengine: devam etmek i�in.
�ok g�zel olacakt�r.

Bu d�k�manda Kaynaklar�, e�itimi, videolar�, ve fazlas�n� bulabilirsiniz.

Go kodu ile nas�l �al���labilece�ini ��renmek i�in, [[http://www.youtube.com/watch?v=XCsL89YtqCs][bu videoyu]]izleyebilir ya da [[http://golang.org/doc/code.html][How to Write Go Code]] dok�man�n� okuyabilirsiniz.

Standart k�t�phane ile ilgili yard�ma ihtiyac�n�z olursa, [[http://golang.org/pkg/][kaynak pakete]]bir g�z at�n. Dilin kendisine yard�m etmek i�in, [[http://golang.org/ref/spec][Dil Belirtimi]]'ni, epey okunabilir buldu�unuzda �a��rabilirsiniz.

Go'nun e�zamanl� modeli hakk�nda daha fazla ara�t�rma i�in, [[http://golang.org/doc/codewalk/sharemem/][�leti�imde Payla��lan Haf�za]]'ya g�z at�n.

[[http://golang.org/doc/codewalk/functions/][Go'da Birinci S�n�f Fonksiyonlar]] Go'nun fonksiyon tipleri hakk�nda ilgin� bir bak�� a��s� sunacakt�r. 

[[http://blog.golang.org/][Go Blog]], Go makaleleriyle alakal� b�y�k bir ar�ive sahip.

Daha fazlas� i�in [[http://golang.org][golang.org]]'u ziyaret edin.

