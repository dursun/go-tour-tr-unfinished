Go Turu

Go Yazarları Sunar
http://golang.org

# Bu dosya içerisinde #appengine komutuyla başlayan
# satırlar var. Bu satırlar tur içeriği, bir App Engine
# uygulaması olarak yüklendiğinde işe yarar.
# Ayrıca, #appengine satırının arkasına gelen boş olmayan
# satırlar saklanacaktır. Bu App Engine'ın özel-içeriğinin
# değiştirilebilmesiyle alakalı bir durum.
# Örneğin, bu paragraf
# 	We are running
# 	#appengine: on App Engine.
# 	locally.
# 	Yay!
# App Engine'da "We are running on App Engine. Yay!" şeklinde okunurken,
# diğer durumlarda "We are running locally. Yay!" şeklinde okunur.

* Merhaba, 世界

 [[http://golang.org/][Go programlama dili ]] turuna hoş geldiniz.

Turumuz 3 bölümden oluşmaktadır: basit kavramlar, metodlar ve arayüzler, ve eşzamanlılık. 

Her bölümün sonunda bir dizi alıştırmayı tamamlamanız beklenmektedir.

Turumuz etkileşimlidir. Programı uzak sunucu üzerinde derleyip, çalıştırmak için "Çalıştır" butonuna tıklayın (ya da Shift-Enter tuşlayın) kod derlenip, program
#appengine: uzak sunucuda
kendi bilgisayarınızda
çalıştırılacak.
Sonuç kodun aşağısında gösterilecek.

Örnek programlar sizi Go'nun farklı yönleriyle tanıştırarak, gelecekteki tecrübeleriniz için ilk adımları oluşturacak.

Programı düzenleyip yeniden çalıştırın.

İlerlemeye hazır olduğunuzda aşağıdaki sağ oka tıklayın ya da PageDown tuşlayın.
Aynı zamanda gezinmek için sayfanın üzerinde, "Go" bayrağının altında bulunan menüyü de kullanabilirsiniz.

.play prog/tour/hello.go

* Go lokal

Turu diğer dillerle de deneyebilirsiniz:

- [[http://go-tour-br.appspot.com/][Brazilian Portuguese — Português do Brasil]]
- [[http://go-tour-ca.appspot.com/][Catalan — Català]]
- [[http://go-tour-es.appspot.com/][Spanish — Español]]
- [[http://go-tour-fr.appspot.com/][French - Français]]
- [[http://go-tour-he.appspot.com/][Hebrew — עִבְרִית]]
- [[http://go-tour-jp.appspot.com/][Japanese — 日本語]]
- [[http://go-tour-ro.appspot.com/][Romanian - Româna]]
- [[http://go-tour-zh.appspot.com/][Chinese — 普通话]]

Devam etmek için "İleri" butonuna tıklayın ya da Page Down tuşlayın.

#appengine: * Go Playground
#appengine: 
#appengine: Bu tur [[http://golang.org/][golang.org]] sunucuları üzerinde çalışan
#appengine: [[http://play.golang.org/][Go Playground]] web servisi üzerine kurulmuştur.
#appengine: 
#appengine: Bu servis, Go programını, bir sanal alan içerisine alıp, derler, bağlar ve çalıştırır.
#appengine: ve çıktıyı döndürür.
#appengine: 
#appengine: Playground içinde çalıştırılabilen programların kısıtlamaları var:
#appengine: 
#appengine: - Playground standart kütüphaneyi, bazı eksikliklerle, kullanabilir; en önemli eksiklikler ağ ve dosya sistemi erişimi. Bu nedenle, playground programının dış dünyayla tek iletişimi "standard output" ve "standard error"dur.
#appengine: - Playground'ta zaman 2009-11-10 23:00:00 UTC'de başlar (bu değerin önemi okuyucu için bir alıştırma niteliğinde olmasıdır). Bu programlara deterministik çıkışlar vererek önbelleğe alınmalarını kolaylaştırır.
#appengine: - Yürütme zamanı, CPU, bellek kullanımında da kısıtlamalar var ve program tek bir iş parçacığı("thread") içerisinde çalışacak şekilde kısıtlanmıştır (ama birçok gorutini kullanabilir).
#appengine:
#appengine: Playground Go'nun son kararlı sürümünü kullanır.
#appengine: 
#appengine: .play prog/tour/sandbox.go

* Paketler

Her Go programı paketlerden oluşur.

Programlar `main` paketinde çalışmaya başlar.

Bu örnek program `"fmt"` ve `"math/rand"` paketlerini import yolu ile kullanıyor.

Geleneksel olarak, paket isimleri import yolunun son elementi ile isimlendirilir. Örneğin, `"math/rand"` paketi, `package`rand`deyimi ile başlayan dosyaları kapsar.

#appengine: *Not:* Bu programların yürütüldüğü ortam belirleyicidir,
#appengine: yani `rand.Intn` her zaman aynı sayıyı döndürecektir.
#appengine: 
#appengine: (Farklı bir sayı görmek için, sayı üreticisini besleyin; [[http://golang.org/pkg/math/rand/#Seed][`rand.Seed`]]'e göz atın.)

.play prog/tour/packages.go

* İçe Aktarımlar

Bu kod, içe aktarılan paketleri, parantezlenmiş alanda, parçalara ayrılmış import deyimi şeklinde gruplar. Ayrıca çoklu import deyimleri de kullanabilirsiniz:

	import "fmt"
	import "math"

.play prog/tour/imports.go

* İçe Aktarılan İsimler

Bir paketi içe aktardıktan sonra, sahip olduğu isimleri de aktarabilirsiniz.

Go'da, dışa aktarılmış bir isim büyük harf ile başlar.

Tıpkı `FOO` gibi `Foo` da dışa aktarılmış bir isimdir. `foo` ise dışa aktarılmış bir isim değildir.

Kodu çalıştırmayı denedikten sonra "`math.pi`"yi  `math.Pi` şeklinde değiştirip yeniden çalıştırın.

.play prog/tour/exported-names.go

* Fonksiyonlar

Bir fonksiyon 0 veya daha fazla argüman alabilir.

Bu örnekte, `add` fonksiyonu `int` tipinde 2 parametre alıyor.

Tip tanımlamasının değişken adından _sonra_ yapıldığına dikkat edin!

(Tiplerin neden buna ihtiyaç duydukları hakkında daha fazla bilgi için, [[[http://golang.org/doc/articles/gos_declaration_syntax.html][buraya]] bakın makale Go'nun "sözdizimi açıklaması"ndandır.)

.play prog/tour/functions.go

* Fonksiyonlar devamı

Ardışık fonksiyon parametreleri aynı tipi paylaşıyorsa, tip adını en sona yazarak tanımlama yapabiliriz.

Bu örnekte,

x int, y int

kod parçası aşağıdaki şekilde kısaltılmış;

x, y int

.play prog/tour/functions-continued.go

* Çoklu sonuçlar

Bir fonksiyon herhangi bir sayıda sonuç döndürebilir.

Örnekteki fonksiyon dizgi tipinde 2 sonuç döndürüyor.

.play prog/tour/multiple-results.go

* İsimlendirilmiş sonuçlar

Fonksiyonlar parametreler alırlar. Go'da fonksiyonlar birden fazla sonuç ("result") parametresi alabilir. Sonuçlar da değişken gibi isimlendirilebilir ve o şekilde davranabilir.

Eğer sonuç parametreleri isimlendirilmişse, argümansız bir `return` deyimi sonuçların geçerli değerini döndürecektir.

.play prog/tour/named-results.go

* Değişkenler

`var` deyimi ile değişkenleri tanımlarız; tıpkı fonksiyon argümanları gibi, tip tanımlaması sonda yapılır.

.play prog/tour/variables.go

* Değişkenler-İlklendirme

Bir `var` deyimi, her değişken için bir ilklendirme değeri içerebilir.

Eğer bir ilklendirme mevcut ise, tip tanımlaması atlanabilir; değişken, ilklendirme değerinin tipini alacaktır.

.play prog/tour/variables-with-initializers.go

* Kısa atama bildirimleri 

Bir fonksiyon içerisinde, `var` yerine `:=` kısa ataması kullanılabilir.

(Fonksiyonun dışında, her yapı bir anahtar kelime ile başlar ve `:=` kısa atamasını kullanmak mümkün değildir.)

.play prog/tour/short-variable-declarations.go

* Basit tipler

Go'nun basit tipleri şunlardır

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // diğer adıyla uint8

	rune // diğer adıyla int32
	     // represents a Unicode code point

	float32 float64

	complex64 complex128

.play prog/tour/basic-types.go

* Sabitler

Sabitler de değişkenler ile aynı şekilde tanımlanır ancak sabitler tanımlanırken `const` anahtar kelimesi kullanılır.

Sabitler; karakter, dizgi, boolean, ya da sayısal değerler alabilir.

Sabitler `:=` kısa atama ifadesi ile atanamazlar.

.play prog/tour/constants.go

* Sayısal Sabitler

Sayısal sabitler yüksek hassasiyetli _değerlerdir_.

Tipi olmayan bir sabit kaynağının ihtiyaç duyduğu tipi alır.

`needInt(Big)` kodunu da eklemeyi deneyin.

.play prog/tour/numeric-constants.go

* For

Go dilinde döngü yapısı olarak sadece `for` mevcuttur.

`for` döngüsü C ya da Java'dakiyle benzer yapıdadır, ancak `(`)` kısmı (parantezler) kullanılmaz (opsiyonel değil)

bunun yanında `{`}` kısmının kullanılması şarttır.

.play prog/tour/for.go

* For devamı

Tıpkı C ve Java'daki gibi, ilk ve son deyimleri boş bırakabilirsiniz.

.play prog/tour/for-continued.go

* For, Go'nun "while"ı

Bu durumda, noktalı virgülleri kullanmayabilirsiniz: C'deki `while`'ın karşılığı Go'da `for`'dur.

.play prog/tour/for-is-gos-while.go

* Forever

Eğer döngü koşulunu belirtmezseniz, sonsuz döngü oluşacaktır.

.play prog/tour/forever.go

* If

`if` koşulu C ve Java'dakiyle benzer yapıdadır ancak `(`)` (parantezlerin) yerini` {`}` (süslü parantezler) alır.

(Tanıdık mı geldi?)

.play prog/tour/if.go

* Kısa atama ile if

`for`'daki gibi, `if` deyimi de koşuldan önce çalıştırılabilmesi için kısa atama ile başlayabilir.

Değişkenlerin geçerliliği `if` koşulunun kapsamı içindedir.

(Sondaki return deyiminde `v` kullanmayı deneyin.)

.play prog/tour/if-with-a-short-statement.go

* If ve else

`if`'in içerisinde kısa atama ile atanan değişkenlerin kullanımı `else` bloklarında da mümkündür.

.play prog/tour/if-and-else.go

* Uygulama: Döngüler ve Fonksiyonlar

Newton’ un yöntemini kullanarak karekök alma fonksiyonu gerçeklemek, fonksiyon ve döngü kullanarak alıştırma yapmanın kolay bir yoludur.

Newton'un metodu kendisine bir _z_ başlangıç noktası seçer ve

.image static/newton.png

formülünü tekrarlayarak `Sqrt(x)` değerine yaklaşır.

Başlangıç olarak, bu hesaplamayı 10 defa tekrar edin ve (1, 2, 3, ...) gibi çeşitli değerlerde cevaba ne kadar yaklaştığınızı görün.

Daha sonra, döngü koşulunu, sonuç değeri değişmeyi bıraktığında (ya da çok küçük bir delta ile değiştiğinde) döngünün duracağı şekilde biçimlendirin.

Daha fazla ya da daha az yineleme için buraya göz atın.

[[http://golang.org/pkg/math/#Sqrt][`Math.sqrt`'ye]] ne kadar yakınsınız?

İpucu: bir kayan nokta değerini (floating point value) ifade etmek ve tanımlamak için kayan nokta söz dizimi verin ya da bir dönüştürme uygulayın:

	z := float64(1)
	z := 1.0

.play prog/tour/exercise-loops-and-functions.go

* Yapılar

Bir struct (yapı) alanların toplamasıdır.

(Ve bir `type` bildirimi bekleneni gerçekleştirir.)

.play prog/tour/structs.go

* Yapı Alanları

Yapı alanları nokta kullanılarak çağrılır

.play prog/tour/struct-fields.go

* İşaretçiler

Go'nun işaretçileri var ama işaretçi aritmetiği yok.

Yapı alanlarına bir yapı işaretçisi ile de erişilebilir. İşaretçi ile sağlanan bu dolaylı yol şeffaftır.

.play prog/tour/pointers.go

* Yapısal Sabitler

Yapısal sabitler, henüz tahsis edilmiş yapı değerini, alanına göre listeleyerek belirtir.

`Name`: sözdizimini kullanarak yalnızca alt alanları listeleyebilirsiniz (Sırasıyla isimlendirilmiş alanlar konu dışındadır.)

Özel `&` gösterimi yapısal bir sabite işaretçi tahsis eder.

.play prog/tour/struct-literals.go

* Yeni fonksiyon

`new(T)` ifadesi, sıfırlanmış bir `T` değeri tahsis eder ve ona bir işaretçi döndürür.

	var t *T = new(T)

ya da

	t := new(T)

.play prog/tour/the-new-function.go

* Dilimler

Bir dilim değerlerden oluşan bir diziyi işaret etmesinin yanında uzunluğunu da belirtir.

`[]T`, `T` tipinden elemanları olan bir dilimdir.

.play prog/tour/slices.go

* Dilim dilim dilimlemek

Bir dilim, aynı diziyi işaret eden yeni bir dilim değeri oluşturmak için yeniden dilimlenebilir.

	s[lo:hi]

ifadesi, `"lo"`dan, `"hi-1"`i de kapsayan elemanları değerlendirir. Buna göre

	s[lo:lo]

dilimi boştur,

	s[lo:lo+1]

dilimi ise bir elemana sahiptir.

.play prog/tour/slicing-slices.go

* Dilim yaratmak

Dilimler `make` fonksiyonu ile yaratılır.Çalışma mantığı; bellekte sıfırlanmış bir dizi tahsis ederek ve bu diziyi işaret eden bir dilim döndürmektir:

	a := make([]int, 5)  // len(a)=5

Kapasiteyi belirtmek için, `make`'e bir üçüncü argüman atayalım:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play prog/tour/making-slices.go

* Nil dilimler

Boş bir dilimin değeri `nil`'dir.

Böyle dilimlerin uzunluk ve kapasite değerleri 0'dır.

(Dilimler hakkında daha fazla bilgi için: [[http://golang.org/doc/articles/slices_usage_and_internals.html] makalesini okuyun)

.play prog/tour/nil-slices.go

* [Erim]("Range")

`for` döngüsünün `range` formu ile bir dilim veya eşlem üzerinde dolaşılır.

.play prog/tour/range.go

* Range devamı

İndisi ya da değeri `_` ataması ile atlayabilirsiniz.

Eğer yalnızca indisi istiyorsanız, “, value” kısmını tamamen çıkarabilirsiniz.

.play prog/tour/range-continued.go

* Uygulama: Dilimler

`"Pic"`i gerçekleyin. Fonksiyonunuz `dx`'in (8 bitlik işaretsiz tam sayılar) dilimi olan her bir eleman için, `dy` uzunluğunda bir dilim döndürmelidir. Programı çalıştırdığınızda, sizin fotoğrafınızı gösterecek, tamsayıları griölçekli (*/uygun çeviri değil*/, maviölçekli) değerler olarak çıkaracaktır.

Resim seçimi size ait. Kullanacağınız fonksiyonlar `x^y`, `(x+y)/2` ve `x*y` işlemlerini içermektedir.

(`[][]uint8` içerisindeki her "`[]uint8`"i ayırmak için döngü kullanmanız gerekmektedir.)

(Tipler arasında dönüşüm yapmak için `uint8(intValue)` kullanın.)

.play prog/tour/exercise-slices.go

* Eşlemler

Bir eşlem, ("map") anahtarları değerlere eşler.

Eşlemler mutlaka `make` ile yaratılmalıdır (`new` ile değil) `nil` tipindeki bir eşlem boştur ve atanabilir değildir.


.play prog/tour/maps.go

* Map değişmezleri

Eşlem değişmezleri de yapı değişmezlerine benzer yapıdadır ancak anahtarlarla birlikte kullanılır.

.play prog/tour/map-literals.go

* Map değişmezleri devamı

Eğer üst-seviye tip yalnızca tip adı ise, onu değişmezin elemanları arasında görmezden gelebilirsiniz.

.play prog/tour/map-literals-continued.go

* Eşlemleri Değiştirme
Eşlemimize ("map") bir eleman ekleyelim ya da varolan bir elemanı güncelleyelim  `m`:

	m[key] = elem

Bir elemanı çekelim:

	elem = m[key]

Bir elemanı silelim:

	delete(m, key)

Çift-değer atamasındaki anahtarı test edelim:

	elem, ok = m[key]

Eğer `key`, `m` içindeyse, `ok`, `true` değerini alacaktır. Eğer değilse, `ok`, `false` değerini alacak ve `elem`, eşlemin eleman tipi için sıfır değerini alacaktır.

Benzer şekilde, bir eşlemden okurken eğer anahtar mevcut değilse Sonuç, eşlemin eleman tipi için sıfır değerini alır.

.play prog/tour/mutating-maps.go

* Uygulama: Eşlemler

`WordCount` fonksiyonunu gerçekleyin. Fonksiyonunuz `s` dizgisinin içerisindeki her bir “kelime” için bir eşlem döndürmelidir. `wc.Test` fonksiyonu, fonksiyonunuzu test edecek ve başarıyı ya da başarısızlığı çıktı olarak verecektir.

"[[http://golang.org/pkg/strings/#Fields][strings.Fields]]"a bakmanızda fayda var.

.play prog/tour/exercise-maps.go

* Fonksiyon değerleri

Fonksiyonlar da birer değerdir.

.play prog/tour/function-values.go

* Fonksiyon - kaplamlar

Go fonksiyonları kaplam ("closure") olabilirler. Kaplam, kendi bloğunun dışından değişkenleri çeken bir fonksiyon değeridir. Fonksiyon çekilen değerlere erişip, atama yapabilir; bu örnekte fonksiyon

`adder` fonksiyonu bir kaplam döndürür. Her kaplam kendi `sum` değişkenini saklar.

.play prog/tour/function-closures.go

* Uygulama: Fibonacci closure

Hadi fonksiyonlarla biraz eğlenelim.

Öyle bir `fibonacci` fonksiyonu tasarlayın ki; ardışık fibonacci sayıları döndüren bir fonksiyon (kaplam) döndürsün.

.play prog/tour/exercise-fibonacci-closure.go

* Anahtarlama

Muhtemelen `"switch"` yapısının ne şekilde çalıştığı hakkında biraz bilginiz vardır.

`"fallthrough durumu"` oluşmaması halinde, uygun case gövdesi çalışacaktır.

.play prog/tour/switch.go

* Anahtarlama değerlendirme sırası

"Switch", "case"lerini baştan aşağı değerlendirir, "case"lerden biri doğrulanırsa değerlendirme işlemi durur.

(Örneğin,

	switch i {
	case 0:
	case f():
	}

eğer`i==0` ise `f`'yi çağırmaz.)

#appengine: *Not:* Go Playground'ta zaman her daim 2009-11-10 23:00:00 UTC'den başlar, 
#appengine: bu değerin önemi okuyucu için bir alıştırma niteliğinde olmasıdır.

.play prog/tour/switch-evaluation-order.go

* Koşulsuz Anahtarlama

Koşul belirtilmemiş bir "switch", bir `"switch`true"` ile aynı işi görür.

Ve uzun "if-then-else" zincirleri yerine kullanılabilecek, güzel bir yöntemdir.

.play prog/tour/switch-with-no-condition.go

* Gelişmiş Uygulama: Karmaşık küp kökler

Go'nun kompleks sayılar için, içinde bulundurduğu `complex64` ve `complex128` tiplerini inceleyelim. Küp kökler için, Newton'un yöntemi:

.image static/newton3.png

formülünü tekrarlayarak sonuca gider.

Algoritmanın çalıştığından emin olmak için, 2'nin küp kökünü bulun. `math/cmplx` paketinin içinde bir [[http://golang.org/pkg/math/cmplx/#Pow][Pow]] fonksiyonu bulunmaktadır.

.play prog/tour/advanced-exercise-complex-cube-roots.go

* Metodlar ve Arayüzler

İlerleyen slaytlar metodlar ve arayüzleri, nesne tanımlamaları ve onların davranış biçimlerini içeren yapıları kapsıyor. 

* Metodlar

Go dilinde sınıf yapısı bulunmamasına karşın "struct" tiplerinde metod tanımlayabilirsiniz.

_Metod_alıcısı_ , `func` anahtar sözcüğü ve metod ismi arasında kendi argüman listesinde bulunur.

.play prog/tour/methods.go

* Metodlar devamı

Hatta sadece "struct"larda değil, metodunuzu paketinizde tanımladığınız _herhangi_ bir tipte de tanımlayabilirsiniz.

Başka bir paketten alacağınız bir tipte ya da temel bir tipte metod tanımlayamazsınız.

.play prog/tour/methods-continued.go

* İşaretçi alıcılarıyla metodlar

Metodlar isimlendirilmiş tiplerle ya da isimlendirilmiş bir tipi gösteren işaretçilerle ilişkilendirilebilir.

Henüz, biri `*Vertex` işaretçi tipinde ve diğeri ise `MyFloat` değer tipinde olmak üzere iki `Abs` metodu gördük.

İşaretçi alıcısı kullanmamızın iki nedeni var. Birincisi, her metod çağrısında, değer kopyalamasından kaçınmak (eğer tipi "large struct" ise daha verimli). İkincisi, metodun işaretçiler sayesinde değeri güncelleyebimesidir.

`*Vertex` yerine `Vertex`'i alıcı olarak kullanmak için, `Abs` ve `Scale` metodlarının bildirimlerini değiştirmeyi deneyin.

`v` bir `Vertex` olduğunda, `Scale` Metodunun bir işlevi yoktur. `Scale`, `v`'yi dönüştürür. `v` bir değer olduğunda (işaretçi-değil), metod onu `Vertex`'in bir kopyası olarak görecek ve asıl değeri dönüştürmeyecektir.

`Abs`  diğer bir şekilde de çalışır. Yalnızca `v`'yi okur. Burada asıl değeri okumasıyla kopyalanmış değeri okuması (işaretçi vasıtasıyla) arasında bir fark yoktur.

.play prog/tour/methods-with-pointer-receivers.go

* Arayüzler

Bir arayüz ("interface") tipi bir dizi metod tarafından belirlenir.

Arayüz tipinin herhangi bir değeri metodarı gerçekleyen değerlerden herhangi birini tutabilir.

.play prog/tour/interfaces.go

* Arayüzler

Bir tip, arayüzü, gerçeklenen metodları kullanarak gerçekler.

_Niyetin_aşikar_bir_açıklaması_yoktur._ /* bu çeviriyi uygun bulmamakla birlikte daha düzgün bir çeviri önerisi sunamıyorum */

Soyutlanmış arayüzler, uygulama paketlerini, arayüzlerin tanımlandığı paketlerden ayırırlar: birbirlerine bağlı da değillerdir.

Aynı zamanda duyarlı arayüzlerin tanımlanması için teşvik eder, çünkü her uygulamayı tek tek bulup yeni bir arayüz ismiyle etiketlemek zorunluluğunu ortadan kaldırır.

[[http://golang.org/pkg/io/][Package io]], `Reader` ve `Writer`'ı otomatik olarak tanımlar.

.play prog/tour/interfaces-are-satisfied-implicitly.go

* Hatalar

Kendini hata dizgisi olarak tarif edebilen her şey bir "hata"dır. Bu fikir önceden tasarlanmış, yerleşik arayüz tipinde, `error`'da, dizgi döndüren, kendi tekil metoduyla (`Error`) saklanır,:

	type error interface {
		Error() string
	}

`fmt` paketlerinin kendi çıktı tipleri bir "`error`" çıktısı istendiğinde onu nasıl sunacaklarını otomatik olarak bilir.

.play prog/tour/errors.go

* Uygulama: Hatalar

`Sqrt` fonksiyonunuzu önceki egzersizlerden kopyalayın ve onu bir `error` (hata) değeri döndürecek şekilde düzenleyin.

`Sqrt` fonksiyonunuz negatif bir sayı verildiğinde, tıpkı kompleks sayıları desteklemediğinde yapacağı gibi, nil olamayan bir hata mesajı döndürmelidir.

Yeni bir tip oluşturun

	type ErrNegativeSqrt float64

ve ona bir

	func (e ErrNegativeSqrt) Error() string

metodu ekleyerek `error` haline getirin `ErrNegativeSqrt(-2).Error()`'un `"Negatif sayıların karekökü alınamaz: -2"` döndürmesi gibi.

*Not:* `Error` metodunun içindeki `"fmt.Print(e)"`e yapılan bir çağrı programı sonsuz bir döngünün içerisine sokacaktır. Öncelikle e'yi değiştirerek bunu önleyebilirsiniz: `fmt.Print(float64(e))`. Neden?

`Sqrt` fonksiyonunuzu negatif sayı verildiğinde `ErrNegativeSqrt` döndürecek biçimde değiştirin.

.play prog/tour/exercise-errors.go

* Web sunucuları

[[http://golang.org/pkg/net/http/][http paketi]] HTTP isteklerini, `http.Handler`’ ı gerçekleyen değerleri kullanarak karşılar:

	package http

	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

Bu örnekte, Hello tipi "http.Handler"ı gerçekliyor.

Selamlamayı görmek için [[http://localhost:4000/][http://localhost:4000/]]'i ziyaret edin.

#appengine: *Not:* Bu örnek web-tabanlı kullanıcı arayüzünde çalışmayacaktır.
#appengine: Web sunucusu yazmayı denemek için
#appengine: [[http://golang.org/doc/install/][Go'yu yükleyin]].

.play prog/tour/web-servers.go

* Uygulama: HTTP İşleyicileri

ServeHTTP metodlarını tanımlamak için aşağıdaki tipleri kullanın. Web sunucunuzdaki spesifik yolları kontrol edebilmek için kaydedin.

	type String string

	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

Örneğin, işleyici kayıtlarını kaydedebilir olmalısınız:

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

.play prog/tour/exercise-http-handlers.go

* Görüntüler

[[http://golang.org/pkg/image/#Image][image paketi]], `Image` arayüzünü tanımlar:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

(Detaylar için [[http://golang.org/pkg/image/#Image][bu dokümana]] göz atın.)

Ayrıca, `color.Color` ve `color.Model` da birer arayüzdür ancak `color.RGBA` ve `color.RGBAModel` öntanımlı uygulamaları için bunu görmezden geleceğiz.

.play prog/tour/images.go

* Uygulama: Görüntüler

Daha önceden yazdığınız görüntü vericiyi hatırladınız mı? Hadi bir tane daha yazalım ama bu defa bir veri dilimi döndürmek yerine `image.Image` döndürsün.

Kendi Image tipinizi tanımlayın, [[http://golang.org/pkg/image/#Image][gerekli metodları]] gerçekleyin ve "`pic.ShowImage`"i çağırın.

`Bounds`, `image.Rect(0, `0, `w, `h)` gibi bir `image.Rectangle` döndürmelidir.

`ColorModel`, `color.RGBAModel` döndürmeli.

`At` bir renk döndürmelidir; son görüntü vericideki `v` değeri bu defa `color.RGBA{v, `v, `255, `255}`'e tekabül etmelidir.

.play prog/tour/exercise-images.go

* Uygulama: Rot13 Okuyucu

Bilindik modellerden biri [[http://golang.org/pkg/io/#Reader][io.Reader]]'ın  `başka bir io.Reader`' ı sarıp, bir şekilde akışı düzenlemesidir.

Örneğin, [[http://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] fonksiyonu bir `io.Reader` alır ("gzipped" verinin bir parçası) ve onu bir `*gzip.Reader`'a çevirir ayrıca `io.Reader`'ı da gerçekler (sıkıştırılmış verinin bir parçası).

[[http://en.wikipedia.org/wiki/ROT13][ROT13]] kullanarak alfabedeki tüm harfleri şifreleyen `io.Reader`'dan okuyup yine `io.Reader`'a yazan bir `rot13Reader`'ı, veri akışını düzenleyerek uygulayın.

`rot13Reader` tipini kullanabilirsiniz. `Read` metodunu
kullanarak onu bir `io.Reader` haline getirin.

.play prog/tour/exercise-rot-reader.go

* Eşzamanlılık

İlerideki bölüm Go'nun ilkel("primitif") eşzamanlılık özelliğini içeriyor.

* Go rutinleri

"_gorutini_" Go tarafından yönetilen hafif bir iş parçacığıdır.

	go f(x, y, z)

yeni bir gorutini başlatır

	f(x, y, z)

'`f`', '`x`', '`y`' ve '`z`'nin değerlendirilmesi aynı gorutinde `f`'nin içinde, `f`'nin değerlendirilmesi ise yeni bir gorutininde gerçekleşir.

Gorutinleri aynı adres boşluğunda çalışır, bu yüzden paylaşılmış bellek erişimi mutlaka senkronize edilmelidir. `[[http://golang.org/pkg/sync/][sync]]` paketi yararlı "ilkellikler" sağlar, yine de Go'da başka "ilkel paketler" olduğundan buna çok ihtiyaç duymayacaksınız. (Bir sonraki slayta geçin.)

.play prog/tour/goroutines.go

* Kanallar

Kanallar, kanal operatörü, `<-`, vasıtasıyla değer gönderip alabildiğiniz veri akışını sağlayan tiplerdir.

	ch <- v    // v'yi ch kanalına yolla.
	v := <-ch  // ch'den al ve
           // değeri v'ye ata.

(Veri akışı ok yönünde gerçekleşir.)

Tıpkı eşlemler ve dilimler gibi kanallar da:

	ch := make(chan int)

kullanılmadan önce oluşturulmalıdır.
Varsayılan olarak, diğer taraf da hazır olduğunda blok gönderme/alma işlemleri yapılır. Bu da gorutinlerini açık kilitlenmelerden ya da koşullu değişkenlerin senkronize edilememesinden korur.

.play prog/tour/channels.go

* Tamponlu Kanallar

Kanallar _tamponlanabilir_.  Tamponlanmış bir kanalı tanımlamak için ikinci argümanı `make` edip, tampon uzunluğunu temin edin:

	ch := make(chan int, 100)

Kodu, bloğu yalnızca tampon dolu olduğunda tamponlanmış kanala gönderir. /* daha düzgün bir çeviri önerim yok ancak üzerinde çalışmamız gerek */

Tampon boş olduğunda ise bloğu temin eder. /* daha düzgün bir çeviri önerim yok ancak üzerinde çalışmamız gerek */

Örneği, tampon gereğinden fazla dolacak şekilde düzenleyip, ne olduğunu gözlemleyin.

.play prog/tour/buffered-channels.go

* Range ve Close

Gönderici bir kanalı daha fazla değer alınmaması gerektiğinde `close` kodu ile kapatabilir. Alıcılar, alıcı ifadeye ikinci bir parametre ataması yaparak kanalın kapalı olup olmadığını öğrenebilir:

	v, ok := <-ch

Eğer alınacak başka değer kalmamış ve kanal kapatılmışsa `ok`, `false` değerini alacaktır.

`for i := range c` döngüsü değerleri kanaldan kanal kapanana kadar düzenli olarak alır.

*Not:* Yalnızca gönderen kanalı kapatmalıdır, alıcı asla kapatmamalıdır. Kapalı kanala bir şeyler göndermek paniğe yol açabilir.

*Bir*başka*not*: Kanallar dosya gibi değildir; genellikle kapatma ihtiyacı duyulmaz. Kapatma işlemi yalnızca alıcıya daha başka değer gelmeyeceğini bildirmek maksadıyla yapılır, tıpkı bir "`range`" döngüsünü sonlandırmak gibi.

.play prog/tour/range-and-close.go

* Seçmek

"`select`" deyimi gorutinin birden fazla iletişim işleminde beklemesine izin verir.

Bir `select`, "case"lerinden biri çalıştırılabilene kadar tıkalıdır, uygun duruma geldiğinde "case"i çalıştırır.  Eğer birden fazla çalıştırılabilir "case" varsa seçimi rastgele gerçekleştirir.

.play prog/tour/select.go

* Varsayılan Seçim

"`default` “case” i, "`select`" in içerisindedir eğer hazırda başka case yoksa çalıştırılır.

"`default` case"i bloklama yapmadan alma ya da gönderme yapmak için deneyin:

	select {
	case i := <-c:
		// i'yi kulllan
	default:
		// c'den almak bloklamalıydı
	}

.play prog/tour/default-selection.go

* Uygulama: Eşdeğer Binary Ağaçları

Değerleri aynı sırada depolanmış birden fazla binary apacı olabilir. Örneğin, burada iki binary ağacı var 1, 1, 2, 3, 5, 8, 13.

.image static/tree.png

Bir çok dilde, aynı sırada iki binary ağacı olup olmadığını kontrol eden fonksiyon bir fonksiyon gerçeklemek bir hayli karışıktır. Daha basit bir çözüm sunabilmek adına Go'nun eşzamanlılığını ve kanallarını kullanacağız.

Bu örnek `tree` paketini kullanır, bu paket:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}
tiplerini tanımlar.

* Uygulama: Eşdeğer Binary Ağaçları

*1.* `Walk` fonksiyonunu çağırın.

*2.* `Walk` fonksiyonunu test edin.

"`tree.New(k)`" fonksiyonu `k`, `2k`, `3k`, ..., `10k` değerlerini tutarak rastgele-yapılandırılmış bir binary ağacı inşa eder.

`ch` adında bir kanal oluşturun ve walker'ı dışarı atın:

	go Walk(tree.New(1), ch)

Daha sonra kanaldan 10 değerini okuyun ve yazın. Değerler 1, 2, 3, ..., 10 olmalı.

*3.* `t1` ve `t2`'nin aynı değerleri saklamasına karşın `Same` fonksiyonunu `Walk` kullanarak uygulayın.

*4.* `Same` fonksiyonunu test edin.

`Same(tree.New(1),`tree.New(1))` true döndürmeli ve `Same(tree.New(1),`tree.New(2))` false döndürmeli.

.play prog/tour/exercise-equivalent-binary-trees.go

* Uygulama: Web Crawler

Bu uygulamada Go'nun eşzamanlılık özelliğini web crawler ile paralelleştirmeyi öğreneceksiniz.

`Crawl` fonksiyonunu paraleldeki URL'leri çekecek biçimde düzenleyin, aynı URL'yi iki defa çekmemesine dikkat edin.

.play prog/tour/exercise-web-crawler.go

* Buradan nereye gidiyoruz...

#appengine: [[http://golang.org/doc/install/][Go yükleyerek]] ya da
#appengine: [[http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go][Go App Engine SDK]]
#appengine: indirerek başlayabilirsiniz.

#appengine: Bir defa Go'yu yüklediğinizde,
[[http://golang.org/doc/][Go Dokümantasyonu]]
#appengine: devam etmek için çok güzel olacaktır.
başlamak için çok güzel olacaktır.

Bu dokümanda Kaynakları, eğitimi, videoları, ve fazlasını bulabilirsiniz.

Go kodu ile nasıl çalışılabileceğini öğrenmek için, [[http://www.youtube.com/watch?v=XCsL89YtqCs][bu videoyu]]izleyebilir ya da [[http://golang.org/doc/code.html][How to Write Go Code]] dokümanını okuyabilirsiniz.

Standart kütüphane ile ilgili yardıma ihtiyacınız olursa, [[http://golang.org/pkg/][kaynak pakete]]bir göz atın. Dilin kendisine yardım etmek için, [[http://golang.org/ref/spec][Dil Belirtimi]]'ni, epey okunabilir bulduğunuzda şaşırabilirsiniz.

Go'nun eşzamanlı modeli hakkında daha fazla araştırma için, [[http://www.youtube.com/watch?v=f6kdp27TYZs][Go Eşzamanlılık Şablonu]]'nu
ve[[https://www.youtube.com/watch?v=QDDwwePbDtw][ Go Gelişmiş Eşzamanlılık Şablonu]]'nu izleyin ve
([[http://talks.golang.org/2012/concurrency.slide][slides]])[[http://golang.org/doc/codewalk/sharemem/][İletişimde Paylaşılan Hafıza]]'ya göz atın.

Web uygulamaları yazmaya başlamak için,
[[http://vimeo.com/53221558][Basit Programlama Çerçevesi]]'ni
([[http://talks.golang.org/2012/simple.slide][slayltları]]) izleyin ve
[[http://golang.org/doc/articles/wiki/][Web Uygulamaları Yazma]] rehberini okuyun.

[[http://golang.org/doc/codewalk/functions/][Go'da Birinci Sınıf Fonksiyonlar]] Go'nun fonksiyon tipleri hakkında ilginç bir bakış açısı sunacaktır.

[[http://blog.golang.org/][Go Blog]], Go makaleleriyle alakalı büyük bir arşive sahip.

Daha fazlası için [[http://golang.org][golang.org]]'u ziyaret edin.

