Go Turu

Go Yazarları Sunar
http://golang.org

# Bu dosya içerisinde #appengine komutuyla başlayan
# satırlar var. Bu satırlar tur içeriği, bir App Engine
# uygulaması olarak yüklendiğinde işe yarar.
# Ayrıca, #appengine satırının arkasına gelen boş olmayan
# satırlar saklanacaktır. Bu App Engine'ın özel-içeriğinin
# değiştirilebilmesiyle alakalı bir durum.
# Örneğin, bu paragraf
# 	We are running
# 	#appengine: on App Engine.
# 	locally.
# 	Yay!
# App Engine'da "We are running on App Engine. Yay!" şeklinde okunurken,
# diğer durumlarda "We are running locally. Yay!" şeklinde okunur.

* Merhaba, 世界

 [[http://golang.org/][Go programlama dili ]] turuna hoş geldiniz.

Turumuz 3 bölümden oluşmaktadır ve her bölümün sonunda bir dizi alıştırmayı tamamlamanız beklenmektedir.

Turumuz etkileşimlidir. Programı uzak sunucu üzerinde derleyip, çalıştırmak için "Çalıştır" butonuna tıklayın (ya da Shift-Enter tuşlayın) kod derlenip, program
#appengine: uzak sunucuda
kendi bilgisayarınızda
çalıştırılacak.

Sonuç kodun aşağısında gösterilecek.

Örnek programlar sizi Go'nun farklı yönleriyle tanıştırarak, gelecekteki tecrübeleriniz için ilk adımları oluşturacak.

Programı düzenleyip yeniden çalıştırın.

İlerlemeye hazır olduğunuzda "İleri" butonuna tıklayın ya da PageDown tuşlayın.
.play prog/hello.go

* Go lokal

Turu diğer dillerle de deneyebilirsiniz:

- [[http://go-tour-br.appspot.com/][Brazilian Portuguese — Português do Brasil]]
- [[http://go-tour-ca.appspot.com/][Catalan — Català]]
- [[http://go-tour-he.appspot.com/][Hebrew — ????????]]
- [[http://go-tour-jp.appspot.com/][Japanese — ???]]
- [[http://go-tour-ro.appspot.com/][Romanian - Româna]]
- [[http://go-tour-zh.appspot.com/][Chinese — ???]]

Devam etmek için "İleri" butonuna tıklayın ya da Page Down tuşlayın.

* Paketler

Her Go programı paketlerden oluşur.

Programlar `main` paketinde çalışmaya başlar.

Bu örnek program `"fmt"` ve `"math"` paketlerini import yolu ile kullanıyor.

Geleneksel olarak, paket isimleri import yolunun son elementi ile isimlendirilir.

.play prog/packages.go

* İçe Aktarımlar

Bu kod grupları import ifadesini parantezlenmiş ifadenin içine aktarırlar. Ayrıca çoklu import ifadeleri de kullanabilirsiniz:

	import "fmt"
	import "math"
ancak karışıklığı önlemek için genellikle parantezler içerisinde ki düzen kullanılır.

.play prog/imports.go

* İçe Aktarılan İsimler

Bir paketi içe aktardıktan sonra, sahip olduğu isimleri de aktarabilirsiniz. 

Go'da, dışa aktarılmış bir isim büyük harf ile başlar.

Tıpkı `FOO` gibi `Foo` da dışa aktarılmış bir isimdir. `foo` ise dışa aktarılmış bir isim değildir.

Kodu çalıştırmayı denedikten sonra `math.pi` ifadesini <code>math.Pi</code> şeklinde değiştirip yeniden çalıştırın.

.play prog/exported-names.go

* Fonksiyonlar

Bir fonksiyon 0 veya daha fazla argüman alabilir.

Bu örnekte, `add` fonksiyonu `int` tipinde 2 parametre alıyor.

Tip tanımlamasının değişken adından _sonra_ yapıldığına dikkat edin!

(Tiplerin neden buna ihtiyaç duydukları hakkında daha fazla bilgi için, [[[http://golang.org/doc/articles/gos_declaration_syntax.html][buraya]] bakın makale Go'nun "syntax ifadesi"ndendir.)

.play prog/functions.go

* Fonksiyonlar

Ardışık fonksiyon parametreleri aynı tipi paylaşıyorsa, tip adını en sona yazarak tanımlama yapabiliriz.

Bu örnekte,

x int, y int

kod parçası aşağıdaki şekilde kısaltılmış;

x, y int

.play prog/functions-continued.go

* Çoklu sonuçlar

Bir fonksiyon herhangi bir sayıda sonuç döndürebilir.

Örnekteki fonksiyon dizgi tipinde 2 sonuç döndürüyor.

.play prog/multiple-results.go

* İsimlendirilmiş sonuçlar

Fonksiyonlar parametreler alırlar. Go'da fonksiyonlar birden fazla sonuç ("result") parametresi alabilir. Sonuçlar da değişken gibi isimlendirilebilir
ve o şekilde davrabilir.

Eğer sonuç parametreleri isimlendirilmişse, argümansız bir `return` ifadesi sonuçların geçerli değerini döndürecektir.
.play prog/named-results.go

* Değişkenler

`var` ifadesi ile değişkenleri tanımlarız;
tıpkı fonksiyon argümanları gibi, tip tanımlaması sonda yapılır.

.play prog/variables.go

* Değişkenler-İlklendirme

Bir `var` ifadesi her değişken için bir ilklendirme değeri içerebilir.

Eğer bir ilklendirme mevcut ise, tip tanımlaması atlanabilir;
değişken ilklendirme değerinin tipini alacaktır.


Bir `var` ifadesi, her değişken için birer tane tanımlayıcı içerebilir.

Eğer bir tanımlayıcı mevcut ise, tip atlanabilir; değişken tanımlayıcısının tipini alacaktır.

.play prog/variables-with-initializers.go

* Kısa atama ifadeleri

Bir fonksiyon içerisinde, `var` ifadesinin yerine `:=` yapısı kullanılabilir .

(Fonksiyonun dışında, her yapı bir anahtar kelime ile başlar ve `:=` yapısını kullanmak mümkün değildir.)

.play prog/short-variable-declarations.go

* Basit tipler

Go'nun basit tipleri şunlardır

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // diğer adıyla uint8

	rune // diğer adıyla int32
	     // represents a Unicode code point

	float32 float64

	complex64 complex128

.play prog/basic-types.go

* Sabitler

Sabitlerde değişkenler ile aynı şekilde tanımlanır ancak sabitler tanımlanırken `const` anahtar kelimesi kullanılır.

Sabitler; karakter, dizgi, boolean, ya da sayısal değerler alabilir.

.play prog/constants.go

* Sayısal Sabitler

Sayısal sabitler yüksek hassasiyetli _değerlerdir_.

Tipi olmayan bir sabit kaynağının ihtiyaç duyduğu tipi alır.

`needInt(Big)` kodunu da eklemeyi deneyin.

.play prog/numeric-constants.go

* For

Go dilinde döngü yapısı olarak sadece `for` mevcuttur.

`for` döngüsü C ya da Java'dakiyle benzer yapıdadır, ancak `(`)` kısmı (parantezler) kullanılmaz (opsiyonel değil) 

bunun yanında `{`}` kısmının kullanılması şarttır.

.play prog/for.go

* For devamı

Tıpkı C ve Java'daki gibi, ilk ve son ifadeleri boş bırakabilirsiniz.

.play prog/for-continued.go

* For, Go'nun "while"ı

Bu durumda, noktalı virgülleri kullanmayabilirsiniz: C'deki `while`'ın karşılığı Go'da `for`'dur.

.play prog/for-is-gos-while.go

* Sonsuzluk

Eğer döngü koşulunu belirtmezseniz, sonsuz döngü oluşacaktır.

.play prog/forever.go

* If

`if` koşulu C ve Java'dakiyle benzer yapıdadır ancak `(`)` (parantezlerin) yerini` {`}` (süslü parantezler) alır.

(Tanıdık mı geldi?)

.play prog/if.go

* Kısa atama ile if

`for`'daki gibi, `if` ifadesi de koşuldan önce çalıştırılabilmesi için kısa atama ile başlayabilir.

Değişkenlerin geçerliliği `if` ifadesinin kapsamı içindedir.

(Sondaki return ifadesinde `v` kullanmayı deneyin.)

.play prog/if-with-a-short-statement.go

* If ve else

`if`'in içerisinde kısa atama ile atanan değişkenlerin kullanımı `else` bloklarında da mümkündür.

.play prog/if-and-else.go

* Uygulama: Döngüler ve Fonksiyonlar

Newton’ un yöntemini kullanarak karekök alma fonksiyonu gerçeklemek, fonksiyon ve döngü kullanarak alıştırma yapmanın kolay bir yoludur.

Newton'un metodu kendisine bir _z_ başlangıç noktası seçer ve

.image static/newton.png

formülünü tekrarlayarak `Sqrt(x)` değerine yaklaşır.

Başlangıç olarak, bu hesaplamayı 10 defa tekrar edin ve (1, 2, 3, ...) gibi çeşitli değerlerde cevaba ne kadar yaklaştığınızı görün.

Daha sonra, döngü koşulunu, sonuç değeri değişmeyi bıraktığında (ya da çok küçük bir delta ile değiştiğinde) Döngünün duracağı şekilde biçimlendirin.

Daha fazla ya da daha az yineleme için buraya göz atın.

[[http://golang.org/pkg/math/#Sqrt][`Math.sqrt`'ye]] ne kadar yakınsınız?

İpucu: bir kayan nokta değerini (floating point value)ifade etmek ve tanımlamak için kayan nokta söz dizimi verin ya da bir dönüştürme uygulayın:

	z := float64(1)
	z := 1.0

.play prog/exercise-loops-and-functions.go

* Yapılar

Bir struct (yapı) alanların toplamasıdır.

(Ve bir `type` ifadesi bekleneni gerçekleştirir.)

.play prog/structs.go

* Yapı Alanları

Yapı alanları nokta kullanılarak çağrılır

.play prog/struct-fields.go

* İşaretçiler

Go'nun işaretçileri var ama işaretçi aritmetiği yok.

Yapı alanlarına bir yapı işaretçisi ile de erişilebilir. İşaretçi ile sağlanan bu dolaylı yol şeffaftır.

.play prog/pointers.go

* Yapısal Sabitler

Yapısal sabitler, henüz tahsis edilmiş yapı değerini, alanına göre listeleyerek belirtir.

`Name`: sözdizimini kullanarak yalnızca alt alanları listeleyebilirsiniz (Sırasıyla isimlendirilmiş alanlar konu dışındadır.)

Özel `&` gösterimi yapısal bir sabite işaretçi tahsis eder.

.play prog/struct-literals.go

* Yeni fonksiyon

`new(T)` ifadesi, sıfırlanmış bir `T` değeri tahsis eder ve ona bir işaretçi döndürür.

	var t *T = new(T)

or

	t := new(T)

.play prog/the-new-function.go

# TODO(campoy): Dizilerin bölümü

* Dilimler

Bir dilim değerlerden oluşan bir diziyi işaret etmesinin yanında uzunluğunu da belirtir.

`[]T`, `T` tipinden elemanları olan bir dilimdir.

.play prog/slices.go

* Dilim dilim dilimlemek

Bir dilim, aynı diziyi işaret eden yeni bir dilim değeri oluşturmak için yeniden dilimlenebilir.

	s[lo:hi]

ifadesi `"lo"`dan `"hi-1"`i de kapsayan elemanları değerlendirir. Buna göre

	s[lo:lo]

dilimi boştur,

	s[lo:lo+1]

dilimi ise bir elemana sahiptir.

.play prog/slicing-slices.go

* Dilim yaratmak

Dilimler `make` fonksiyonu ile yaratılır.Çalışma mantığı; bellekte sıfırlanmış bir dizi tahsis ederek ve bu diziyi işaret eden bir dilim döndürmektir:

	a := make([]int, 5)  // len(a)=5

Kapasiteyi belirtmek için, `make`'e bir üçüncü argüman atayalım:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play prog/making-slices.go

* Nil dilimler

Boş bir dilimin değeri `nil`'dir.

Böyle dilimlerin uzunluk ve kapasite değerleri 0'dır.

(Dilimler hakkında daha fazla bilgi için: [[http://golang.org/doc/articles/slices_usage_and_internals.html] makalesini okuyun)

.play prog/nil-slices.go

# TODO(campoy): Dilimler bölümüne ekleme 

* [Erim]("Range")

`for` döngüsünün `range` formu ile bir dilim veya eşlem üzerinde dolaşılır.

.play prog/range.go

* Range devamı

İndisi ya da değeri `_` ataması ile atlayabilirsiniz.

Eğer yalnızca indisi istiyorsanız, “, value” ifadesini tamamen çıkarabilirsiniz.

.play prog/range-continued.go

* Uygulama: Dilimler

`"Pic"`i gerçekleyin. Fonksiyonunuz `dx`'in (8 bitlik işaretsiz tam sayılar) dilimi olan her bir eleman için, `dy` uzunluğunda bir dilim döndürmelidir.

Programı çalıştırdığınızda, sizin fotoğrafınızı gösterecek, tamsayıları griölçekli (*/uygun çeviri değil*/, maviölçekli) değerler olarak çıkaracaktır.

Resim seçimi size ait. Kullanacağınız fonksiyonlar `x^y`, `(x+y)/2` ve `x*y` ifadelerini içermektedir.

(`[][]uint8` içerisindeki her "`[]uint8`"i ayırmak için döngü kullanmanız gerekmektedir.)

(Tipler arasında dönüşüm yapmak için uint8(intValue) kullanın.)

.play prog/exercise-slices.go

* Eşlemler

Bir eşlem ("map") anahtarları değerlere eşler.

Eşlemler mutlaka `make` ile yaratılmalıdır (`new` ile değil) `nil` tipindeki bir eşlem boştur ve atanabilir değildir.


.play prog/maps.go

* Map değişmezleri

Eşlem değişmezleri de yapı değişmezlerine benzer yapıdadır ancak anahtarlarla birlikte kullanılır.

.play prog/map-literals.go

* Map değişmezleri devamı

Eğer üst-seviye tip yalnızca tip adı ise, onu değişmezin elemanları arasında görmezden gelebilirsiniz. /*kendime not daha uygun bir çeviri ara */

.play prog/map-literals-continued.go

* Eşlemleri Değiştirme
Eşlemimize ("map") bir eleman ekleyelim ya da varolan bir elemanı güncelleyelim  `m`:

	m[key] = elem

Bir elemanı çekelim:

	elem = m[key]

Bir elemanı silelim:

	delete(m, key)

Çift-değer atamasındaki anahtarı test edelim:

	elem, ok = m[key]

Eğer `key`, `m` içindeyse, `ok`, `true` değerini alacaktır. Eğer değilse, `ok`, `false` değerini alacak ve `elem`, 

eşlemin eleman tipi için sıfır değerini alacaktır.

Benzer şekilde, bir eşlemden okurken eğer anahtar mevcut değilse Sonuç, eşlemin eleman tipi için sıfır değerini alır.

.play prog/mutating-maps.go

# TODO(campoy): Range on maps section

* Uygulama: Eşlemler

`WordCount` fonksiyonunu gerçekleyin. Fonksiyonunuz `s` dizgisinin içerisindeki her bir “kelime” için bir eşlem döndürmelidir. `wc.Test` fonksiyonu, fonksiyonunuzu test edecek ve başarıyı ya da başarısızlığı çıktı olarak verecektir.

"[[http://golang.org/pkg/strings/#Fields][strings.Fields]]"a bakmanızda fayda var.

.play prog/exercise-maps.go

* Fonksiyon değerleri

Fonksiyonlar da birer değerdir.

.play prog/function-values.go

* Fonksiyon - kaplamlar

Fonksiyonlar kaplamlarla ("closure") doludur.

`adder` fonksiyonu bir kaplam döndürür. Her kaplam kendi `sum` değişkenini saklar.

.play prog/function-closures.go

* Uygulama: Fibonacci closure

Hadi fonksiyonlarla biraz eğlenelim.

`Fibonacci` uygulaması ardışık Fibonacci sayılarını döndüren bir fonksiyonu, kaplamı döndürür.

.play prog/exercise-fibonacci-closure.go

* Anahtarlama

Muhtemelen `"switch"` yapısının ne şekilde çalıştığı hakkında biraz bilginiz vardır.

`"fallthrough durumu"` oluşmaması halinde, uygun case gövdesi çalışacaktır . /* çevirimin uygunluğu hakkında şüphelerim var */

.play prog/switch.go

* Anahtarlama değerlendirme sırası

"Switch", "case"lerini baştan aşağı değerlendirir, "case"lerden biri doğrulanırsa değerlendirme işlemi durur.

(Örneğin,

	switch i {
	case 0:
	case f():
	}

eğer`i==0` ise `f`'yi çağırmaz.)

#appengine: *Note:* Time in the Go playground always appears to start at
#appengine: 2009-11-10 23:00:00 UTC, a value whose significance is left as an
#appengine: exercise for the reader.

.play prog/switch-evaluation-order.go

* Koşulsuz Anahtarlama

Koşul belirtilmemiş bir "switch" ifadesi `"switch`true"` ifadesi ile aynı işi görür.

Ve uzun "if-then-else" zincirleri yerine kullanılabilecek, güzel bir yöntemdir.

.play prog/switch-with-no-condition.go

* Gelişmiş Uygulama: Karmaşık küp kökler

Go'nun kompleks sayılar için, içinde bulundurduğu `complex64` ve `complex128` tiplerini inceleyelim. Küp kökler için, Newton'un yöntemi:

.image static/newton3.png

formülünü tekrarlayarak sonuca gider.

Algoritmanın çalıştığından emin olmak için, 2'nin küp kökünü bulun. `math/cmplx` paketinin içinde bir [[http://golang.org/pkg/math/cmplx/#Pow][Pow]] fonksiyonu bulunmaktadır.

.play prog/advanced-exercise-complex-cube-roots.go

* Metodlar ve Arayüzler

* Metodlar

Go dilinde sınıf yapısı bulunmamasına karşın "struct" tiplerinde metod tanımlayabilirsiniz.

_Metod_alıcısı_ , `func` anahtar sözcüğü ve metod ismi arasında kendi argüman listesinde bulunur.

.play prog/methods.go

* Metodlar devamı

Hatta sadece "struct"larda değil, metodunuzu paketinizde tanımladığınız _herhangi_ bir tipte de tanımlayabilirsiniz.

Başka bir paketten alacağınız bir tipte ya da temel bir tipte metod tanımlayamazsınız.

.play prog/methods-continued.go

* İşaretçi alıcılarıyla metodlar

Metodlar isimlendirilmiş tiplerle ya da isimlendirilmiş bir tipi gösteren işaretçilerle ilişkilendirilebilir.

Henüz, biri `*Vertex` işaretçi tipinde ve diğeri ise `MyFloat` değer tipinde olmak üzere iki `Abs` metodu gördük.

İşaretçi alıcısı kullanmamızın iki nedeni var. Birincisi, her metod çağrısında, değer kopyalamasından kaçınmak (eğer tipi "large struct" ise daha verimli). İkincisi, metodun işaretçiler sayesinde değeri güncelleyebimesidir.

`*Vertex` yerine `Vertex`'i alıcı olarak kullanmak için `Abs` ve `Scale` metod ifadelerini değiştirmeyi deneyin.

`v` bir `Vertex` olduğunda, `Scale` Metodunun bir işlevi yoktur. `Scale`, `v`'yi dönüştürür. `v` bir değer olduğunda (işaretçi-değil), metod onu `Vertex`'in bir kopyası olarak görecek ve asıl değeri dönüştürmeyecektir.

`Abs`  diğer bir şekilde de çalışır. Yalnızca `v`'yi okur. Burada asıl ifadeyi okumasıyla kopyalanmış ifadeyi okuması (işaretçi vasıtasıyla) arasında bir fark yoktur.

.play prog/methods-with-pointer-receivers.go

* Arayüzler

Bir arayüz ("interface") tipi bir dizi metod tarafından belirlenir.

Arayüz tipinin herhangi bir değeri metodarı gerçekleyen değerlerden herhangi birini tutabilir.

.play prog/interfaces.go

* Arayüzler

Bir tip, arayüzü, gerçeklenen metodları kullanarak gerçekler. /* çok kötü bir çeviri oldu üzerinde düşünmek gerek 

_Niyetin_aşikar_bir_açıklaması_yoktur._ /* bu çeviriyi uygun bulmamakla birlikte daha düzgün bir çeviri önerisi sunamıyorum */

Soyutlanmış arayüzler, uygulama paketlerini arayüzlerin tanımlandığı 

paketlerden ayırırlar: birbirlerine bağlı da değillerdir.

Aynı zamanda –doğru terimi bulamadım- arayüzlerin tanımlanması için teşvik eder, çünkü

her uygulamayı tek tek bulup yeni bir arayüz ismiyle etiketlemek zorunluluğunu ortadan kaldırır.

[[http://golang.org/pkg/io/][Package io]], `Reader` ve `Writer`'ı otomatik olarak tanımlar.

.play prog/interfaces-are-satisfied-implicitly.go

* Hatalar

Kendini hata dizgisi olarak tarif edebilen her şey bir "hata"dır.

Bu fikir önceden tasarlanmış, yerleşik arayüz tipinde, `error`'da,

dizgi döndüren, kendi tekil metoduyla (`Error`) saklanır,:

`fmt` paketlerinin kendi çıktı tipleri bir "`error`"

çıktısı istendiğinde onu nasıl sunacaklarını otomatik olarak bilir.

.play prog/errors.go

* Uygulama: Hatalar

`Sqrt` fonksiyonunuzu önceki egzersizlerden kopyalayın ve onu bir `error` (hata) değeri döndürecek şekilde düzenleyin.

`Sqrt` fonksiyonunuz negatif bir sayı verildiğinde, tıpkı kompleks sayıları desteklemediğinde yapacağı gibi. nil olamayan bir hata mesajı döndürmelidir, 

Yeni bir tip oluşturun

	type ErrNegativeSqrt float64

ve ona bir

	func (e ErrNegativeSqrt) Error() string

metodu ekleyere `error` haline getirin `ErrNegativeSqrt(-2).Error()`'un `"Negatif sayıların karekökü alınamaz: -2"` döndürmesi gibi.

*Not:* `Error` metodunun içindeki `"fmt.Print(e)"`e yapılan bir çağrı programı sonsuz bir döngünün içerisine sokacaktır. Öncelikle e'yi değiştirerek bunu önleyebilirsiniz: `fmt.Print(float64(e))`. Neden?

`Sqrt` fonksiyonunuzu negatif sayı verildiğinde `ErrNegativeSqrt` döndürecek biçimde değiştirin.

.play prog/exercise-errors.go

* Web sunucuları

[[http://golang.org/pkg/net/http/][http paketi]] HTTP isteklerini, http.Handler’ ı gerçekleyen değerleri kullanarak karşılar:

	package http

	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

Bu örnekte, Hello tipi "http.Handler"ı gerçekliyor.

Selamlamayı görmek için [[http://localhost:4000/][http://localhost:4000/]]'i ziyaret edin.

#appengine: *Note:* Bu örnek web-tabanlı kullanıcı arayüzünde çalışmayacaktır.
#appengine: Web sunucusu yazmayı denemek için 
#appengine: [[http://golang.org/doc/install/][Go'yu yükleyin]].

.play prog/web-servers.go

* Uygulama: HTTP İşleyicileri

ServeHTTP metodlarını tanımlamak için aşağıdaki tipleri kullanın. Web sunucunuzdaki spesifik yolları kontrol edebilmek için kaydedin.

	type String string

	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

Örneğin, işleyici kayıtlarını kaydedebilir olmalısınız:

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

.play prog/exercise-http-handlers.go

* Görüntüler

[[http://golang.org/pkg/image/#Image][image paketi]], `Image` arayüzünü tanımlar:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

(Detaylar için [[http://golang.org/pkg/image/#Image][bu dokümana]] göz atın.)

Ayrıca, `color.Color` ve `color.Model` da birer arayüzdür ancak `color.RGBA` ve `color.RGBAModel` öntanımlı uygulamaları için bunu görmezden geleceğiz.

.play prog/images.go

* Uygulama: Görüntüler

Daha önceden yazdığınız görüntü vericiyi hatırladınız mı? Hadi bir tane daha yazalım ama bu defa bir veri dilimi döndürmek yerine `image.Image` döndürsün.

Kendi Image tipinizi tanımlayın, [[http://golang.org/pkg/image/#Image][gerekli metodları]] gerçekleyin ve "`pic.ShowImage`"i çağırın.

`Bounds`, `image.Rect(0, `0, `w, `h)` gibi bir `image.Rectangle` döndürmelidir.

`ColorModel`, `color.RGBAModel` döndürmeli.

`At` bir renk döndürmelidir; son görüntü vericideki `v` değeri bu defa `color.RGBA{v, `v, `255, `255}`'e tekabül etmelidir.

.play prog/exercise-images.go

* Uygulama: Rot13 Okuyucu

Bilindik modellerden biri [[http://golang.org/pkg/io/#Reader][io.Reader]]'ın  `başka bir io.Reader`' ı sarıp, bir şekilde akışı düzenlemesidir. /* %100 emin değilim wrap ve stream terimlerine tekrar göz atmak lazım*/

Örneğin, [[http://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]]
fonksiyonu bir `io.Reader` alır ("gzipped" verinin bir parçası)
ve onu bir `*gzip.Reader`'a çevirir ayrıca
`io.Reader`'ı da gerçekler (sıkıştırılmış verinin bir parçası).

[[http://en.wikipedia.org/wiki/ROT13][ROT13]] kullanarak alfabedeki tüm harfleri şifreleyen 
`io.Reader`'dan okuyup yine `io.Reader`'a yazan bir `rot13Reader`'ı, 
veri akışını düzenleyerek uygulayın.
`rot13Reader` tipini kullanabilirsiniz. `Read` metodunu
kullanarak onu bir `io.Reader` haline getirin.

.play prog/exercise-rot-reader.go

* Eşzamanlılık

* Go rutinleri

"_gorutini_" Go tarafından yönetilen hafif bir iş parçacığıdır.

	go f(x, y, z)

	yeni bir gorutini başlatır

	f(x, y, z)

'`f`', '`x`', '`y`' ve '`z`'nin
değerlendirilmesi aynı gorutinde `f`'nin içinde, `f`'nin
değerlendirilmesi ise yeni bir gorutininde gerçekleşir.

Gorutinleri aynı adres boşluğunda çalışır, bu yüzden paylaşılmış bellek erişimi
mutlaka senkronize edilmelidir. `[[http://golang.org/pkg/sync/][sync]]` paketi yararlı "ilkellikler" sağlar,
yine de Go'da başka "ilkel paketler" olduğundan buna çok ihtiyaç duymayacaksınız.
(Bir sonraki slayta geçin.)

.play prog/goroutines.go

* Kanallar

Kanallar, kanal operatörü vasıtasıyla değer gönderip alabildiğiniz veri akışı sağlayan birer tiptir, `<-`.

	ch <- v    // v'yi ch kanalına yolla.
	v := <-ch  // ch'den al ve
           // değeri v'ye ata.

	(Veri akışı ok yönünde gerçekleşir.)

	Tıpkı eşlemler ve dilimler gibi kanallar da:

	ch := make(chan int)

kullanılmadan önce oluşturulmalıdır.
Varsayılan olarak, diğer taraf da hazır olduğunda blok gönderme/alma işlemleri yapılır.
Bu da gorutinlerini açık kilitlenmelerden ya da koşullu değişkenlerin senkronize
edilememesinden korur.

.play prog/channels.go

* Tamponlu Kanallar

Kanallar _tamponlanabilir_.  Tamponlanmış bir kanalı tanımlamak için
ikinci argümanı `make` edip, tampon uzunluğunu temin edin:

	ch := make(chan int, 100)

Kodu, bloğu yalnızca tampon dolu olduğunda tamponlanmış kanala gönderir. /* daha düzgün bir çeviri önerim yok ancak üzerinde çalışmamız gerek */

Tampon boş olduğunda ise bloğu temin eder. /* daha düzgün bir çeviri önerim yok ancak üzerinde çalışmamız gerek */

Örneği, tampon gereğinden fazla dolacak şekilde düzenleyip, ne olduğunu gözlemleyin.

.play prog/buffered-channels.go

* Range and Close

Gönderici bir kanalı daha fazla değer alınmaması gerektiğinde 
`close` kodu ile kapatabilir. Alıcılar, alıcı ifadeye ikinci bir parametre ataması yaparak
kanalın kapalı olup olmadığını öğrenebilir:

	v, ok := <-ch

Eğer alınacak başka değer kalmamış ve kanal kapatılmışsa `ok`, `false` değerini alacaktır.

`for i := range c` döngüsü değerleri kanaldan kanal kapanana kadar düzenli olarak alır.

*Not:* Yalnızca gönderen kanalı kapatmalıdır, alıcı asla kapatmamalıdır.
Kapalı kanala bir şeyler göndermek paniğe yol açabilir.

*Bir*başka*not*: Kanallar dosya gibi değildir; genellikle kapatma ihtiyacı
duyulmaz. Kapatma işlemi yalnızca alıcıya daha başka değer gelmeyeceğini bildirmek
maksadıyla yapılır, tıpkı bir "`range`" döngüsünü sonlandırmak gibi.

.play prog/range-and-close.go

* Seçmek

"`select`" ifadesi gorutinin birden fazla iletişim işleminde beklemesine izin verir.

Bir `select` "case"lerinden biri çalıştırılabilene kadar tıkalıdır, uygun duruma geldiğinde
"case"i çalıştırır.  Eğer birden fazla çalıştırılabilir "case" varsa seçimi rastgele gerçekleştirir.

.play prog/select.go

* Varsayılan Seçim

"`default` “case” i, "`select`" in içerisindedir eğer hazırda başka case yoksa çalıştırılır.

"<code>default</code> case"i bloklama yapmadan alma ya da gönderme yapmak için deneyin:

	select {
	case i := <-c:
		// i'yi kulllan
	default:
		// c'den almak bloklamalıydı
	}

.play prog/default-selection.go

* Uygulama: Eşdeğer Binary Ağaçları

Değerleri aynı sırada depolanmış birden fazla binary apacı olabilir.
Örneğin, burada iki binary ağacı var 1, 1, 2, 3, 5, 8, 13.

.image static/tree.png

Bir çok dilde, aynı sırada iki binary ağacı olup olmadığını kontrol eden fonksiyon bir fonksiyon gerçeklemek
bir hayli karışıktır. Daha basit bir çözüm sunabilmek adına Go'nun eşzamanlılığını ve kanallarını kullanacağız.

Bu örnek <code>tree</code> paketini kullanır, bu paket:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}

tiplerini tanımlar.

* Uygulama: Eşdeğer Binary Ağaçları

*1.* `Walk` fonksiyonunu çağırın.

*2.* `Walk` fonksiyonunu test edin.

"`tree.New(k)`" fonksiyonu `k`, `2k`, `3k`, ..., `10k` değerlerini tutarak rastgele-yapılandırılmış
bir binary ağacı inşa eder.

`ch` adında bir kanal oluşturun ve walker'ı dışarı atın:

	go Walk(tree.New(1), ch)

Daha sonra kanaldan 10 değerini okuyun ve yazın. Değerler 1, 2, 3, ..., 10 olmalı.

*3.* `t1` ve `t2`'nin aynı değerleri saklamasına karşın `Same` fonksiyonunu `Walk` kullanarak uygulayın.

*4.* `Same` fonksiyonunu test edin.

`Same(tree.New(1),`tree.New(1))` true döndürmeli ve `Same(tree.New(1),`tree.New(2))` false döndürmeli.

.play prog/exercise-equivalent-binary-trees.go

* Uygulama: Web Crawler

Bu uygulamada Go'nun eşzamanlılık özelliğini web crawler ile paralelleştirmeyi öğreneceksiniz.

`Crawl` fonksiyonunu paraleldeki URL'leri çekecek biçimde düzenleyin, aynı URL'yi iki defa çekmemesine dikkat edin.

.play prog/exercise-web-crawler.go

* Buradan nereye gidiyoruz...

#appengine: [[http://golang.org/doc/install/][Go yükleyerek]] ya da
#appengine: [[http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go][Go App Engine SDK]]
#appengine: indirerek başlayabilirsiniz.

#appengine: Bir defa Go'yu yüklediğinizde,
The
[[http://golang.org/doc/][Go Dokümantasyonu]] başlangıca
#appengine: devam etmek için.
çok güzel olacaktır.

Bu dökümanda Kaynakları, eğitimi, videoları, ve fazlasını bulabilirsiniz.

Go kodu ile nasıl çalışılabileceğini öğrenmek için, [[http://www.youtube.com/watch?v=XCsL89YtqCs][bu videoyu]]izleyebilir ya da [[http://golang.org/doc/code.html][How to Write Go Code]] dokümanını okuyabilirsiniz.

Standart kütüphane ile ilgili yardıma ihtiyacınız olursa, [[http://golang.org/pkg/][kaynak pakete]]bir göz atın. Dilin kendisine yardım etmek için, [[http://golang.org/ref/spec][Dil Belirtimi]]'ni, epey okunabilir bulduğunuzda şaşırabilirsiniz.

Go'nun eşzamanlı modeli hakkında daha fazla araştırma için, [[http://golang.org/doc/codewalk/sharemem/][İletişimde Paylaşılan Hafıza]]'ya göz atın.

[[http://golang.org/doc/codewalk/functions/][Go'da Birinci Sınıf Fonksiyonlar]] Go'nun fonksiyon tipleri hakkında ilginç bir bakış açısı sunacaktır. 

[[http://blog.golang.org/][Go Blog]], Go makaleleriyle alakalı büyük bir arşive sahip.

Daha fazlası için [[http://golang.org][golang.org]]'u ziyaret edin.

