Go Turu

Go Yazarlarý Sunar
http://golang.org

# Bu dosya içerisinde #appengine komutuyla baþlayan
# satýrlar var. Bu satýrlar tur içeriði, bir App Engine
# uygulamasý olarak yüklendiðinde iþe yarar.
# Ayrýca, #appengine satýrýnýn arkasýna gelen boþ olmayan
# satýrlar saklanacaktýr. Bu App Engine'ýn özel-içeriðinin
# deðiþtirilebilmesiyle alakalý bir durum.
# Örneðin, bu paragraf
# 	We are running
# 	#appengine: on App Engine.
# 	locally.
# 	Yay!
# App Engine'da "We are running on App Engine. Yay!" þeklinde okunurken,
# diðer durumlarda "We are running locally. Yay!" þeklinde okunur.

* Merhaba, ??

 [[http://golang.org/][Go programlama dili ]] turuna hoþ geldiniz.

Turumuz 3 bölümden oluþmaktadýr ve her bölümün sonunda bir dizi alýþtýrmayý tamamlamanýz bekleniyor.

Turumuz etkileþimlidir. Programý uzak sunucu üzerinde derleyip, çalýþtýrmak için "Çal¿¿t¿r"   butonuna týklayýn (ya da Shift-Enter tuþlayýn) kod derlenip, program
#appengine: uzak sunucuda
kendi bilgisayarýnýzda
çalýþtýrýlacak.

Sonuç kodun aþaðýsýnda gösterilecek.

Örnek programlar sizi Go'nun farklý yönleriyle tanýþtýrarak, gelecekteki tecrübeleriniz için ilk adýmlarý oluþturacak.

Programý düzenleyip yeniden çalýþtýrýn.

Ýlerlemeye hazýr olduðunuzda "¿leri" butonuna týklayýn ya da PageDown tuþlayýn.
.play prog/hello.go

* Go lokal

Turu diðer dillerle de deneyebilirsiniz:

- [[http://go-tour-br.appspot.com/][Brazilian Portuguese — Português do Brasil]]
- [[http://go-tour-ca.appspot.com/][Catalan — Català]]
- [[http://go-tour-he.appspot.com/][Hebrew — ????????]]
- [[http://go-tour-jp.appspot.com/][Japanese — ???]]
- [[http://go-tour-ro.appspot.com/][Romanian - Româna]]
- [[http://go-tour-zh.appspot.com/][Chinese — ???]]

Devam etmek için "¿leri" butonuna týklayýn ya da Page Down tuþlayýn.

* Paketler

Her Go programý paketlerden oluþur.

Programlar `main` paketinde çalýþmaya baþlar.

Bu örnek program `"fmt"` ve `"math"` paketlerini import yolu ile kullanýyor.

Geleneksel olarak, paket isimleri import yolunun son elementi ile isimlendirilir.

.play prog/packages.go

* Ýçe Aktarýmlar

Bu kod gruplarý import ifadesini parantezlenmiþ ifadenin içine aktarýrlar. Ayrýca çoklu import ifadeleri de kullanabilirsiniz:

	import "fmt"
	import "math"
ancak karýþýklýðý önlemek için genellikle diðer form kullanýlýr.

.play prog/imports.go

* Ýçe Aktarýlan Ýsimler

Bir paketi içe aktardýktan sonra, sahip olduðu isimleri de aktarabilirsiniz. 

Go'da, dýþa aktarýlmýþ bir isim büyük harf ile baþlar.

Týpký `FOO` gibi `Foo` da dýþa aktarýlmýþ bir isimdir. `foo` dýþa aktarýlmýþ bir isim deðildir.

Kodu çalýþtýrmayý denedikten sonra `math.pi` ifadesini <code>math.Pi</code> þeklinde deðiþtirip yeniden çalýþtýrýn.

.play prog/exported-names.go

* Fonksiyonlar

Bir fonksiyon 0 veya daha fazla argüman alabilir.

Bu örnekte, `add` fonksiyonu `int` tipinde 2 parametre alýyor.

Tip tanýmlamasýnýn deðiþken adýndan _sonra_ yapýldýðýna dikkat edin!

(Tiplerin neden buna ihtiyaç duyduklarý hakkýnda daha fazla bilgi için, [[[http://golang.org/doc/articles/gos_declaration_syntax.html][buraya]] bakýn makale Go'nun "syntax ifadesi"ndendir.)

.play prog/functions.go

* Fonksiyonlar

Ardýþýk gelen 2 ya da daha fazla parametre ayný tipi paylaþýyorsa, tip adýný en sona yazarak tanýmlama yapabiliriz.

Bu örnekte,

x int, y int

kod parçasý aþaðýdaki þekilde kýsaltýlmýþ;

x, y int

.play prog/functions-continued.go

* Çoklu sonuçlar

Bir fonksiyon herhangi bir sayýda sonuç döndürebilir.

Örnekteki fonksiyon dizgi tipinde 2 sonuç döndürüyor.

.play prog/multiple-results.go

* Ýsimlendirilmiþ sonuçlar

Fonksiyonlar parametreler alýrlar. Go'da fonksiyonlar birden fazla sonuç ("result") parametresi alabilir. Sonuçlar da deðiþken gibi isimlendirilebilir
ve o þekilde davrabilir.

Eðer sonuç parametreleri isimlendirilmiþse, argümansýz bir `return` ifadesi sonuçlarýn geçerli deðerini döndürecektir.
.play prog/named-results.go

* Deðiþkenler

`var` ifadesi ile deðiþkenleri tanýmlarýz;
týpký fonksiyon argümanlarý gibi, tip tanýmlamasý sonda yapýlýr.

.play prog/variables.go

* Deðiþkenler-Ýlklendirme

Bir `var` ifadesi her deðiþken için bir ilklendirme deðeri içerebilir.

Eðer bir ilklendirme mevcut ise, tip tanýmlamasý atlanabilir;
deðiþken ilklendirme deðerinin tipini alacaktýr.


Bir var ifadesi tanýmlayýcý içerebilir, her deðiþkene bir tane.

Eðer bir tanýmlayýcý mevcut ise, tip atlanabilir; deðiþken tanýmlayýcýsýnýn tipini alacaktýr.

.play prog/variables-with-initializers.go

* Kýsa atama ifadeleri

Bir fonksiyon içerisinde, `var` ifadesinin yerine `:=` yapýsý kullanýlabilir .

(Fonksiyonun dýþýnda, her yapý bir anahtar kelime ile baþlar ve `:=` yapýsýný kullanmak mümkün deðildir.)

.play prog/short-variable-declarations.go

* Basit tipler

Go'nun basit tipleri þunlardýr

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // diðer adýyla uint8

	rune // diðer adýyla int32
	     // represents a Unicode code point

	float32 float64

	complex64 complex128

.play prog/basic-types.go

* Sabitler

Sabitler de deðiþkenler gibidir ama const anahtar kelimesi ile kullanýlýrlar.

Sabitler, karakter, dizgi, boolean, ya da sayýsal deðerler alabilir.

.play prog/constants.go

* Sayýsal Sabitler

Sayýsal sabitler yüksek hassasiyetli _deðerlerdir_.

Tipi olmayan bir sabit kaynaðýnýn ihtiyaç duyduðu tipi alýr.

`needInt(Big)` kodunu da eklemeyi deneyin.

.play prog/numeric-constants.go

* For

Go dilinde sadece `for` döngüsü mevcuttur.

`for` döngüsü C ya da Java'dakiyle benzer yapýdadýr, ancak `(`)` kýsmý (parantezler) kullanýlmaz (opsiyonel deðil) 

bunun yanýnda `{`}` kýsmýnýn kullanýlmasý þarttýr.

.play prog/for.go

* For devamý

Týpký C ve Java'daki gibi, ilk ve son ifadeleri boþ býrakabilirsiniz.

.play prog/for-continued.go

* For, Go'nun "while"ý

Bu durumda, noktalý virgülleri kullanmayabilirsiniz: C'deki `while`'ýn karþýlýðý Go'da `for`'dur.

.play prog/for-is-gos-while.go

* Sonsuzluk

Eðer döngü koþulunu belirtmezseniz, sonsuz döngü oluþacaktýr.

.play prog/forever.go

* If

`if` koþulu C ve Java'dakiyle benzer yapýdadýr ancak `(`)` (parantezlerin) yerini` {`}` (süslü parantezler) alýr.

(Tanýdýk mý geldi?)

.play prog/if.go

* Kýsa atama ile if

`for`'daki gibi, `if` ifadesi de koþuldan önce çalýþtýrýlabilmesi için kýsa atama ile baþlayabilir.

Deðiþkenlerin geçerliliði `if` ifadesinin kapsamý içindedir.

(Sondaki return ifadesinde `v` kullanmayý deneyin.)

.play prog/if-with-a-short-statement.go

* If ve else

`if`'in içerisinde kýsa atama ile atanan deðiþkenlerin kullanýmý `else` bloklarýnda da mümkündür.

.play prog/if-and-else.go

* Uygulama: Döngüler ve Fonksiyonlar

Newton’ un yöntemini kullanarak karekök alma fonksiyonu gerçeklemek, fonksiyon ve döngü kullanarak alýþtýrma yapmanýn kolay bir yoludur.

Newton'un metodu kendisine bir _z_ baþlangýç noktasý seçer ve

.image static/newton.png

formülünü tekrarlayarak `Sqrt(x)` deðerine yaklaþýr.

Baþlangýç olarak, bu hesaplamayý 10 defa tekrar edin ve (1, 2, 3, ...) gibi çeþitli deðerlerde cevaba ne kadar yaklaþtýðýnýzý görün.

Daha sonra, döngü koþulunu, sonuç deðeri deðiþmeyi býraktýðýnda (ya da çok küçük bir delta ile deðiþtiðinde) Döngünün duracaðý þekilde biçimlendirin.

Daha fazla ya da daha az yineleme için buraya göz atýn.

[[http://golang.org/pkg/math/#Sqrt][`Math.sqrt`'ye]] ne kadar yakýnsýnýz?

Ýpucu: bir kayan nokta deðerini (floating point value)ifade etmek ve tanýmlamak için kayan nokta söz dizimi verin ya da bir dönüþtürme uygulayýn:

	z := float64(1)
	z := 1.0

.play prog/exercise-loops-and-functions.go

* Yapýlar

Bir struct (yapý) alanlarýn toplamasýdýr.

(Ve bir `type` ifadesi bekleneni gerçekleþtirir.)

.play prog/structs.go

* Yapý Alanlarý

Yapý alanlarý nokta kullanýlarak çaðrýlýr

.play prog/struct-fields.go

* Ýþaretçiler

Go'nun iþaretçileri var ama iþaretçi aritmetiði yok.

Yapý alanlarýna bir yapý iþaretçisi ile de eriþilebilir. Ýþaretçi ile saðlanan bu dolaylý yol þeffaftýr.

.play prog/pointers.go

* Yapýsal Sabitler

Yapýsal sabitler, henüz tahsis edilmiþ yapý deðerini, alanýna göre listeleyerek belirtir.

`Name`: sözdizimini kullanarak yalnýzca alt alanlarý listeleyebilirsiniz (Sýrasýyla isimlendirilmiþ alanlar konu dýþýndadýr.)

Özel `&` gösterimi yapýsal bir sabite iþaretçi tahsis eder.

.play prog/struct-literals.go

* Yeni fonksiyon

`new(T)` ifadesi, sýfýrlanmýþ bir `T` deðeri tahsis eder ve ona bir iþaretçi döndürür.

	var t *T = new(T)

or

	t := new(T)

.play prog/the-new-function.go

# TODO(campoy): Dizilerin bölümü

* Dilimler

Bir dilim deðerlerden oluþan bir diziyi iþaret etmesinin yanýnda uzunluðunu da belirtir.

`[]T`, `T` tipinden elemanlarý olan bir dilimdir.

.play prog/slices.go

* Dilim dilim dilimlemek

Bir dilim, ayný diziyi iþaret eden yeni bir dilim deðeri oluþturmak için yeniden dilimlenebilir.

	s[lo:hi]

ifadesi `"lo"`dan `"hi-1"`i de kapsayan elemanlarý deðerlendirir. Buna göre

	s[lo:lo]

dilimi boþtur,

	s[lo:lo+1]

dilimi ise bir elemana sahiptir.

.play prog/slicing-slices.go

* Dilim yaratmak

Dilimler `make` fonksiyonu ile yaratýlýr.Çalýþma mantýðý; bellekte sýfýrlanmýþ bir dizi tahsis ederek ve bu diziyi iþaret eden bir dilim döndürmektir:

	a := make([]int, 5)  // len(a)=5

Kapasiteyi belirtmek için, `make`'e bir üçüncü argüman atayalým:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play prog/making-slices.go

* Nil dilimler

Boþ bir dilimin deðeri `nil`'dir.

Böyle dilimlerin uzunluk ve kapasite deðerleri 0'dýr.

(Dilimler hakkýnda daha fazla bilgi için: [[http://golang.org/doc/articles/slices_usage_and_internals.html] makalesini okuyun)

.play prog/nil-slices.go

# TODO(campoy): Dilimler bölümüne ekleme 

* [Erim]("Range")

`for` döngüsünün `range` formu ile bir dilim veya eþlem üzerinde dolaþýlýr.

.play prog/range.go

* Range devamý

Ýndisi ya da deðeri `_` atamasý ile atlayabilirsiniz.

Eðer yalnýzca indisi istiyorsanýz, “, value” ifadesini tamamen çýkarabilirsiniz.

.play prog/range-continued.go

* Uygulama: Dilimler

`"Pic"`i gerçekleyin. Fonksiyonunuz `dx`'in (8 bitlik iþaretsiz tam sayýlar) dilimi olan her bir eleman için, `dy` uzunluðunda bir dilim döndürmelidir.

Programý çalýþtýrdýðýnýzda, sizin fotoðrafýnýzý gösterecek, tamsayýlarý griölçekli (*/uygun çeviri deðil*/, maviölçekli) deðerler olarak çýkaracaktýr.

Resim seçimi size ait. Kullanacaðýnýz fonksiyonlar `x^y`, `(x+y)/2` ve `x*y` ifadelerini içermektedir.

(`[][]uint8` içerisindeki her "`[]uint8`"i ayýrmak için döngü kullanmanýz gerekmektedir.)

(Tipler arasýnda dönüþüm yapmak için uint8(intValue) kullanýn.)

.play prog/exercise-slices.go

* Eþlemler

Bir eþlem ("map") anahtarlarý deðerlere eþler.

Eþlemler mutlaka `make` ile yaratýlmalýdýr (`new` ile deðil) `nil` tipindeki bir eþlem boþtur ve atanabilir deðildir.


.play prog/maps.go

* Map deðiþmezleri

Eþlem deðiþmezleri de yapý deðiþmezlerine benzer yapýdadýr ancak anahtarlarla birlikte kullanýlýr.

.play prog/map-literals.go

* Map deðiþmezleri devamý

Eðer üst-seviye tip yalnýzca tip adý ise, onu deðiþmezin elemanlarý arasýnda görmezden gelebilirsiniz. /*kendime not daha uygun bir çeviri ara */

.play prog/map-literals-continued.go

* Eþlemleri Deðiþtirme
Eþlemimize ("map") bir eleman ekleyelim ya da varolan bir elemaný güncelleyelim  `m`:

	m[key] = elem

Bir elemaný çekelim:

	elem = m[key]

Bir elemaný silelim:

	delete(m, key)

Çift-deðer atamasýndaki anahtarý test edelim:

	elem, ok = m[key]

Eðer `key`, `m` içindeyse, `ok`, `true` deðerini alacaktýr. Eðer deðilse, `ok`, `false` deðerini alacak ve `elem`, 

eþlemin eleman tipi için sýfýr deðerini alacaktýr.

Benzer þekilde, bir eþlemden okurken eðer anahtar mevcut deðilse Sonuç, eþlemin eleman tipi için sýfýr deðerini alýr.

.play prog/mutating-maps.go

# TODO(campoy): Range on maps section

* Uygulama: Eþlemler

`WordCount` fonksiyonunu gerçekleyin. Fonksiyonunuz `s` dizgisinin içerisindeki her bir “kelime” için bir eþlem döndürmelidir. `wc.Test` fonksiyonu, fonksiyonunuzu test edecek ve baþarýyý ya da baþarýsýzlýðý çýktý olarak verecektir.

"[[http://golang.org/pkg/strings/#Fields][strings.Fields]]"a bakmanýzda fayda var.

.play prog/exercise-maps.go

* Fonksiyon deðerleri

Fonksiyonlar da birer deðerdir.

.play prog/function-values.go

* Fonksiyon - kaplamlar

Fonksiyonlar kaplamlarla ("closure") doludur.

`adder` fonksiyonu bir kaplam döndürür. Her kaplam kendi `sum` deðiþkenini saklar.

.play prog/function-closures.go

* Uygulama: Fibonacci closure

Hadi fonksiyonlarla biraz eðlenelim.

`Fibonacci` uygulamasý ardýþýk Fibonacci sayýlarýný döndüren bir fonksiyonu, kaplamý döndürür.

.play prog/exercise-fibonacci-closure.go

* Anahtarlama

Muhtemelen `"switch"` yapýsýnýn ne þekilde çalýþtýðý hakkýnda biraz bilginiz vardýr.

`"fallthrough durumu"` oluþmamasý halinde, uygun case gövdesi çalýþacaktýr . /* çevirimin uygunluðu hakkýnda þüphelerim var */

.play prog/switch.go

* Anahtarlama deðerlendirme sýrasý

"Switch", "case"lerini baþtan aþaðý deðerlendirir, "case"lerden biri doðrulanýrsa deðerlendirme iþlemi durur.

(Örneðin,

	switch i {
	case 0:
	case f():
	}

eðer`i==0` ise `f`'yi çaðýrmaz.)

#appengine: *Note:* Time in the Go playground always appears to start at
#appengine: 2009-11-10 23:00:00 UTC, a value whose significance is left as an
#appengine: exercise for the reader.

.play prog/switch-evaluation-order.go

* Koþulsuz Anahtarlama

Koþul belirtilmemiþ bir "switch" ifadesi `"switch`true"` ifadesi ile ayný iþi görür.

Ve uzun "if-then-else" zincirleri yerine kullanýlabilecek, güzel bir yöntemdir.

.play prog/switch-with-no-condition.go

* Geliþmiþ Uygulama: Karmaþýk küp kökler

Go'nun kompleks sayýlar için, içinde bulundurduðu `complex64` ve `complex128` tiplerini inceleyelim. Küp kökler için, Newton'un yöntemi:

.image static/newton3.png

formülünü tekrarlayarak sonuca gider.

Algoritmanýn çalýþtýðýndan emin olmak için, 2'nin küp kökünü bulun. `math/cmplx` paketinin içinde bir [[http://golang.org/pkg/math/cmplx/#Pow][Pow]] fonksiyonu bulunmaktadýr.

.play prog/advanced-exercise-complex-cube-roots.go

* Metodlar ve Arayüzler

* Metodlar

Go dilinde sýnýf yapýsý bulunmamasýna karþýn "struct" tiplerinde metod tanýmlayabilirsiniz.

_Metod_alýcýsý_ , `func` anahtar sözcüðü ve metod ismi arasýnda kendi argüman listesinde bulunur.

.play prog/methods.go

* Metodlar devamý

Hatta sadece "struct"larda deðil, metodunuzu paketinizde tanýmladýðýnýz _herhangi_ bir tipte de tanýmlayabilirsiniz.

Baþka bir paketten alacaðýnýz bir tipte ya da temel bir tipte metod tanýmlayamazsýnýz.

.play prog/methods-continued.go

* Ýþaretçi alýcýlarýyla metodlar

Metodlar isimlendirilmiþ tiplerle ya da isimlendirilmiþ bir tipi gösteren iþaretçilerle iliþkilendirilebilir.

Henüz, biri `*Vertex` iþaretçi tipinde ve diðeri ise `MyFloat` deðer tipinde olmak üzere iki `Abs` metodu gördük.

Ýþaretçi alýcýsý kullanmamýzýn iki nedeni var. Birincisi, her metod çaðrýsýnda, deðer kopyalamasýndan kaçýnmak (eðer tipi "large struct" ise daha verimli). Ýkincisi, metodun iþaretçiler sayesinde deðeri güncelleyebimesidir.

`*Vertex` yerine `Vertex`'i alýcý olarak kullanmak için `Abs` ve `Scale` metod ifadelerini deðiþtirmeyi deneyin.

`v` bir `Vertex` olduðunda, `Scale` Metodunun bir iþlevi yoktur. `Scale`, `v`'yi dönüþtürür. `v` bir deðer olduðunda (iþaretçi-deðil), metod onu `Vertex`'in bir kopyasý olarak görecek ve asýl deðeri dönüþtürmeyecektir.

`Abs`  diðer bir þekilde de çalýþýr. Yalnýzca `v`'yi okur. Burada asýl ifadeyi okumasýyla kopyalanmýþ ifadeyi okumasý (iþaretçi vasýtasýyla) arasýnda bir fark yoktur.

.play prog/methods-with-pointer-receivers.go

* Arayüzler

Bir arayüz ("interface") tipi bir dizi metod tarafýndan belirlenir.

Arayüz tipinin herhangi bir deðeri metodarý gerçekleyen deðerlerden herhangi birini tutabilir.

.play prog/interfaces.go

* Arayüzler

Bir tip, arayüzü, gerçeklenen metodlarý kullanarak gerçekler. /* çok kötü bir çeviri oldu üzerinde düþünmek gerek 

_Niyetin_aþikar_bir_açýklamasý_yoktur._ /* bu çeviriyi uygun bulmamakla birlikte daha düzgün bir çeviri önerisi sunamýyorum */

Soyutlanmýþ arayüzler, uygulama paketlerini arayüzlerin tanýmlandýðý 

paketlerden ayýrýrlar: birbirlerine baðlý da deðillerdir.

Ayný zamanda –doðru terimi bulamadým- arayüzlerin tanýmlanmasý için teþvik eder, çünkü

her uygulamayý tek tek bulup yeni bir arayüz ismiyle etiketlemek zorunluluðunu ortadan kaldýrýr.

[[http://golang.org/pkg/io/][Package io]], `Reader` ve `Writer`'ý otomatik olarak tanýmlar.

.play prog/interfaces-are-satisfied-implicitly.go

* Hatalar

Kendini hata dizgisi olarak tarif edebilen her þey bir "hata"dýr.

Bu fikir önceden tasarlanmýþ, yerleþik arayüz tipinde, `error`'da,

dizgi döndüren, kendi tekil metoduyla (`Error`) saklanýr,:

`fmt` paketlerinin kendi çýktý tipleri bir "`error`"

çýktýsý istendiðinde onu nasýl sunacaklarýný otomatik olarak bilir.

.play prog/errors.go

* Uygulama: Hatalar

`Sqrt` fonksiyonunuzu önceki egzersizlerden kopyalayýn ve onu bir `error` (hata) deðeri döndürecek þekilde düzenleyin.

`Sqrt` fonksiyonunuz negatif bir sayý verildiðinde, týpký kompleks sayýlarý desteklemediðinde yapacaðý gibi. nil olamayan bir hata mesajý döndürmelidir, 

Yeni bir tip oluþturun

	type ErrNegativeSqrt float64

ve ona bir

	func (e ErrNegativeSqrt) Error() string

metodu ekleyere `error` haline getirin `ErrNegativeSqrt(-2).Error()`'un `"Negatif sayýlarýn karekökü alýnamaz: -2"` döndürmesi gibi.

*Not:* `Error` metodunun içindeki `"fmt.Print(e)"`e yapýlan bir çaðrý programý sonsuz bir döngünün içerisine sokacaktýr. Öncelikle e'yi deðiþtirerek bunu önleyebilirsiniz: `fmt.Print(float64(e))`. Neden?

`Sqrt` fonksiyonunuzu negatif sayý verildiðinde `ErrNegativeSqrt` döndürecek biçimde deðiþtirin.

.play prog/exercise-errors.go

* Web sunucularý

[[http://golang.org/pkg/net/http/][http paketi]] HTTP isteklerini, http.Handler’ ý gerçekleyen deðerleri kullanarak karþýlar:

	package http

	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

Bu örnekte, Hello tipi "http.Handler"ý gerçekliyor.

Selamlamayý görmek için [[http://localhost:4000/][http://localhost:4000/]]'i ziyaret edin.

#appengine: *Note:* Bu örnek web-tabanlý kullanýcý arayüzünde çalýþmayacaktýr.
#appengine: Web sunucusu yazmayý denemek için 
#appengine: [[http://golang.org/doc/install/][Go'yu yükleyin]].

.play prog/web-servers.go

* Uygulama: HTTP Ýþleyicileri

ServeHTTP metodlarýný tanýmlamak için aþaðýdaki tipleri kullanýn. Web sunucunuzdaki spesifik yollarý kontrol edebilmek için kaydedin.

	type String string

	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

Örneðin, iþleyici kayýtlarýný kaydedebilir olmalýsýnýz:

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

.play prog/exercise-http-handlers.go

* Görüntüler

[[http://golang.org/pkg/image/#Image][image paketi]], `Image` arayüzünü tanýmlar:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

(Detaylar için [[http://golang.org/pkg/image/#Image][bu dokümana]] göz atýn.)

Ayrýca, `color.Color` ve `color.Model` da birer arayüzdür ancak `color.RGBA` ve `color.RGBAModel` öntanýmlý uygulamalarý için bunu görmezden geleceðiz.

.play prog/images.go

* Uygulama: Görüntüler

Daha önceden yazdýðýnýz görüntü vericiyi hatýrladýnýz mý? Hadi bir tane daha yazalým ama bu defa bir veri dilimi döndürmek yerine `image.Image` döndürsün.

Kendi Image tipinizi tanýmlayýn, [[http://golang.org/pkg/image/#Image][gerekli metodlarý]] gerçekleyin ve "`pic.ShowImage`"i çaðýrýn.

`Bounds`, `image.Rect(0, `0, `w, `h)` gibi bir `image.Rectangle` döndürmelidir.

`ColorModel`, `color.RGBAModel` döndürmeli.

`At` bir renk döndürmelidir; son görüntü vericideki `v` deðeri bu defa `color.RGBA{v, `v, `255, `255}`'e tekabül etmelidir.

.play prog/exercise-images.go

* Uygulama: Rot13 Okuyucu

Bilindik modellerden biri [[http://golang.org/pkg/io/#Reader][io.Reader]]'ýn  `baþka bir io.Reader`' ý sarýp, bir þekilde akýþý düzenlemesidir. /* %100 emin deðilim wrap ve stream terimlerine tekrar göz atmak lazým*/

Örneðin, [[http://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]]
fonksiyonu bir `io.Reader` alýr ("gzipped" verinin bir parçasý)
ve onu bir `*gzip.Reader`'a çevirir ayrýca
`io.Reader`'ý da gerçekler (sýkýþtýrýlmýþ verinin bir parçasý).

[[http://en.wikipedia.org/wiki/ROT13][ROT13]] kullanarak alfabedeki tüm harfleri þifreleyen 
`io.Reader`'dan okuyup yine `io.Reader`'a yazan bir `rot13Reader`'ý, 
veri akýþýný düzenleyerek uygulayýn.
`rot13Reader` tipini kullanabilirsiniz. `Read` metodunu
kullanarak onu bir `io.Reader` haline getirin.

.play prog/exercise-rot-reader.go

* Eþzamanlýlýk

* Go rutinleri

"_gorutini_" Go tarafýndan yönetilen hafif bir iþ parçacýðýdýr.

	go f(x, y, z)

	yeni bir gorutini baþlatýr

	f(x, y, z)

'`f`', '`x`', '`y`' ve '`z`'nin
deðerlendirilmesi ayný gorutinde `f`'nin içinde, `f`'nin
deðerlendirilmesi ise yeni bir gorutininde gerçekleþir.

Gorutinleri ayný adres boþluðunda çalýþýr, bu yüzden paylaþýlmýþ bellek eriþimi
mutlaka senkronize edilmelidir. `[[http://golang.org/pkg/sync/][sync]]` paketi yararlý "ilkellikler" saðlar,
yine de Go'da baþka "ilkel paketler" olduðundan buna çok ihtiyaç duymayacaksýnýz.
(Bir sonraki slayta geçin.)

.play prog/goroutines.go

* Kanallar

Kanallar, kanal operatörü vasýtasýyla deðer gönderip alabildiðiniz veri akýþý saðlayan birer tiptir, `<-`.

	ch <- v    // v'yi ch kanalýna yolla.
	v := <-ch  // ch'den al ve
           // deðeri v'ye ata.

	(Veri akýþý ok yönünde gerçekleþir.)

	Týpký eþlemler ve dilimler gibi kanallar da:

	ch := make(chan int)

kullanýlmadan önce oluþturulmalýdýr.
Varsayýlan olarak, diðer taraf da hazýr olduðunda blok gönderme/alma iþlemleri yapýlýr.
Bu da gorutinlerini açýk kilitlenmelerden ya da koþullu deðiþkenlerin senkronize
edilememesinden korur.

.play prog/channels.go

* Tamponlu Kanallar

Kanallar _tamponlanabilir_.  Tamponlanmýþ bir kanalý tanýmlamak için
ikinci argümaný `make` edip, tampon uzunluðunu temin edin:

	ch := make(chan int, 100)

Kodu, bloðu yalnýzca tampon dolu olduðunda tamponlanmýþ kanala gönderir. /* daha düzgün bir çeviri önerim yok ancak üzerinde çalýþmamýz gerek */

Tampon boþ olduðunda ise bloðu temin eder. /* daha düzgün bir çeviri önerim yok ancak üzerinde çalýþmamýz gerek */

Örneði, tampon gereðinden fazla dolacak þekilde düzenleyip, ne olduðunu gözlemleyin.

.play prog/buffered-channels.go

* Range and Close

Gönderici bir kanalý daha fazla deðer alýnmamasý gerektiðinde 
`close` kodu ile kapatabilir. Alýcýlar, alýcý ifadeye ikinci bir parametre atamasý yaparak
kanalýn kapalý olup olmadýðýný öðrenebilir:

	v, ok := <-ch

Eðer alýnacak baþka deðer kalmamýþ ve kanal kapatýlmýþsa `ok`, `false` deðerini alacaktýr.

`for i := range c` döngüsü deðerleri kanaldan kanal kapanana kadar düzenli olarak alýr.

*Not:* Yalnýzca gönderen kanalý kapatmalýdýr, alýcý asla kapatmamalýdýr.
Kapalý kanala bir þeyler göndermek paniðe yol açabilir.

*Bir*baþka*not*: Kanallar dosya gibi deðildir; genellikle kapatma ihtiyacý
duyulmaz. Kapatma iþlemi yalnýzca alýcýya daha baþka deðer gelmeyeceðini bildirmek
maksadýyla yapýlýr, týpký bir "`range`" döngüsünü sonlandýrmak gibi.

.play prog/range-and-close.go

* Seçmek

"`select`" ifadesi gorutinin birden fazla iletiþim iþleminde beklemesine izin verir.

Bir `select` "case"lerinden biri çalýþtýrýlabilene kadar týkalýdýr, uygun duruma geldiðinde
"case"i çalýþtýrýr.  Eðer birden fazla çalýþtýrýlabilir "case" varsa seçimi rastgele gerçekleþtirir.

.play prog/select.go

* Varsayýlan Seçim

"`default` “case” i, "`select`" in içerisindedir eðer hazýrda baþka case yoksa çalýþtýrýlýr.

"<code>default</code> case"i bloklama yapmadan alma ya da gönderme yapmak için deneyin:

	select {
	case i := <-c:
		// i'yi kulllan
	default:
		// c'den almak bloklamalýydý
	}

.play prog/default-selection.go

* Uygulama: Eþdeðer Binary Aðaçlarý

Deðerleri ayný sýrada depolanmýþ birden fazla binary apacý olabilir.
Örneðin, burada iki binary aðacý var 1, 1, 2, 3, 5, 8, 13.

.image static/tree.png

Bir çok dilde, ayný sýrada iki binary aðacý olup olmadýðýný kontrol eden fonksiyon bir fonksiyon gerçeklemek
bir hayli karýþýktýr. Daha basit bir çözüm sunabilmek adýna Go'nun eþzamanlýlýðýný ve kanallarýný kullanacaðýz.

Bu örnek <code>tree</code> paketini kullanýr, bu paket:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}

tiplerini tanýmlar.

* Uygulama: Eþdeðer Binary Aðaçlarý

*1.* `Walk` fonksiyonunu çaðýrýn.

*2.* `Walk` fonksiyonunu test edin.

"`tree.New(k)`" fonksiyonu `k`, `2k`, `3k`, ..., `10k` deðerlerini tutarak rastgele-yapýlandýrýlmýþ
bir binary aðacý inþa eder.

`ch` adýnda bir kanal oluþturun ve walker'ý dýþarý atýn:

	go Walk(tree.New(1), ch)

Daha sonra kanaldan 10 deðerini okuyun ve yazýn. Deðerler 1, 2, 3, ..., 10 olmalý.

*3.* `t1` ve `t2`'nin ayný deðerleri saklamasýna karþýn `Same` fonksiyonunu `Walk` kullanarak uygulayýn.

*4.* `Same` fonksiyonunu test edin.

`Same(tree.New(1),`tree.New(1))` true döndürmeli ve `Same(tree.New(1),`tree.New(2))` false döndürmeli.

.play prog/exercise-equivalent-binary-trees.go

* Uygulama: Web Crawler

Bu uygulamada Go'nun eþzamanlýlýk özelliðini web crawler ile paralelleþtirmeyi öðreneceksiniz.

`Crawl` fonksiyonunu paraleldeki URL'leri çekecek biçimde düzenleyin, ayný URL'yi iki defa çekmemesine dikkat edin.

.play prog/exercise-web-crawler.go

* Buradan nereye gidiyoruz...

#appengine: [[http://golang.org/doc/install/][Go yükleyerek]] ya da
#appengine: [[http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go][Go App Engine SDK]]
#appengine: indirerek baþlayabilirsiniz.

#appengine: Bir defa Go'yu yüklediðinizde,
The
[[http://golang.org/doc/][Go Dokümantasyonu]] baþlangýca
#appengine: devam etmek için.
çok güzel olacaktýr.

Bu dökümanda Kaynaklarý, eðitimi, videolarý, ve fazlasýný bulabilirsiniz.

Go kodu ile nasýl çalýþýlabileceðini öðrenmek için, [[http://www.youtube.com/watch?v=XCsL89YtqCs][bu videoyu]]izleyebilir ya da [[http://golang.org/doc/code.html][How to Write Go Code]] dokümanýný okuyabilirsiniz.

Standart kütüphane ile ilgili yardýma ihtiyacýnýz olursa, [[http://golang.org/pkg/][kaynak pakete]]bir göz atýn. Dilin kendisine yardým etmek için, [[http://golang.org/ref/spec][Dil Belirtimi]]'ni, epey okunabilir bulduðunuzda þaþýrabilirsiniz.

Go'nun eþzamanlý modeli hakkýnda daha fazla araþtýrma için, [[http://golang.org/doc/codewalk/sharemem/][Ýletiþimde Paylaþýlan Hafýza]]'ya göz atýn.

[[http://golang.org/doc/codewalk/functions/][Go'da Birinci Sýnýf Fonksiyonlar]] Go'nun fonksiyon tipleri hakkýnda ilginç bir bakýþ açýsý sunacaktýr. 

[[http://blog.golang.org/][Go Blog]], Go makaleleriyle alakalý büyük bir arþive sahip.

Daha fazlasý için [[http://golang.org][golang.org]]'u ziyaret edin.

